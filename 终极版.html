<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=1220, initial-scale=0.5, user-scalable=no, shrink-to-fit=yes">
    <title>AIå›¾å½¢å‰²è¡¥å·¥å…·</title>
    <style>
        * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Arial', sans-serif;
    background-color: #f0f8ff;
    color: #333;
}

.container {
    max-width: 1220px;
    margin: 0 auto;
    padding: 20px;
    text-align: center;
}

h1 {
    color: #1e5b98;
    margin-bottom: 20px;
    font-size: 2.5rem;
}

.instructions {
    margin-bottom: 20px;
    background-color: #e6f2ff;
    padding: 15px;
    border-radius: 10px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

.canvas-container {
    position: relative;
    margin: 0 auto;
    width: 100%;
    display: flex;
    gap: 20px;
    align-items: flex-start;
}

canvas {
    width: 1120px;
    height: 800px;
    border: 2px solid #4c8dbd;
    border-radius: 10px;
    background-color: #fff;
    cursor: crosshair;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    flex: 0 0 auto;
}

.tools {
    display: flex;
    flex-direction: column;
    gap: 8px;
    flex: 0 0 auto;
    width: 130px;
}

.reset-undo-buttons {
    display: flex;
    flex-direction: row;
    gap: 5px;
    width: 100%;
}

.reset-undo-buttons button {
    flex: 1;
    font-size: 12px;
}

.tool-buttons {
    display: flex;
    flex-direction: column;
    gap: 6px;
    width: 100%;
}

.tool-buttons button {
    width: 100%;
}

.cut-direction {
    margin: 0;
    width: 100%;
    padding: 5px 10px;
    background-color: #e6f2ff;
    border-radius: 5px;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    font-weight: bold;
    color: #1e5b98;
}

.cut-direction label {
    margin-bottom: 5px;
}

.cut-direction select {
    width: 100%;
    border: 1px solid #4c8dbd;
    background-color: white;
    color: #1e5b98;
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 14px;
    cursor: pointer;
    outline: none;
}

.cut-direction select:hover {
    border-color: #1e5b98;
}

.cut-direction select:focus {
    box-shadow: 0 0 0 2px rgba(76, 141, 189, 0.3);
}

.shape-selection {
    margin: 0;
    width: 100%;
    padding: 5px 10px;
    background-color: #e6f2ff;
    border-radius: 5px;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    font-weight: bold;
    color: #1e5b98;
}

.shape-selection label {
    margin-bottom: 5px;
}

.shape-selection select {
    width: 100%;
    border: 1px solid #4c8dbd;
    background-color: white;
    color: #1e5b98;
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 14px;
    cursor: pointer;
    outline: none;
}

.shape-selection select:hover {
    border-color: #1e5b98;
}

.shape-selection select:focus {
    box-shadow: 0 0 0 2px rgba(76, 141, 189, 0.3);
}

.grid-size-selection {
    margin: 0;
    width: 100%;
    padding: 5px 10px;
    background-color: #e6f2ff;
    border-radius: 5px;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    font-weight: bold;
    color: #1e5b98;
}

.grid-size-selection label {
    margin-bottom: 5px;
}

.grid-size-selection select {
    width: 100%;
    border: 1px solid #4c8dbd;
    background-color: white;
    color: #1e5b98;
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 14px;
    cursor: pointer;
    outline: none;
}

.grid-size-selection select:hover {
    border-color: #1e5b98;
}

.grid-size-selection select:focus {
    box-shadow: 0 0 0 2px rgba(76, 141, 189, 0.3);
}

#resetBtn, #scissorsBtn, #penBtn, #gridBtn, #rotateBtn, #flipHorizontalBtn, #setMainShapeBtn, #copyBtn, #deleteBtn, #undoBtn, #finishDrawingBtn {
    background-color: #6ba3d0;
    color: white;
    border: 2px solid transparent;
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.9rem;
    font-weight: 500;
    transition: all 0.3s ease;
    display: inline-block;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

#resetBtn:hover, #scissorsBtn:hover, #penBtn:hover, #gridBtn:hover, #rotateBtn:hover, #flipHorizontalBtn:hover, #setMainShapeBtn:hover, #copyBtn:hover, #deleteBtn:hover, #undoBtn:hover, #finishDrawingBtn:hover {
    background-color: #4c8dbd;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
    border-color: #3273af;
}

button.active {
    background-color: #1e5b98 !important;
    color: #ffffff !important;
    border: 2px solid #ffffff !important;
    box-shadow: 0 0 12px rgba(30, 91, 152, 0.6), 0 4px 8px rgba(0, 0, 0, 0.2) !important;
    transform: translateY(-2px);
    font-weight: bold;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

button.disabled {
    opacity: 0.6;
    cursor: not-allowed !important;
    background-color: #a8c5d9 !important;
    color: #ffffff !important;
    border: 2px solid #d0d0d0 !important;
    box-shadow: none !important;
    transform: none !important;
    font-weight: normal !important;
    text-shadow: none !important;
}

button.disabled:hover {
    background-color: #a8c5d9 !important;
    border-color: #d0d0d0 !important;
    transform: none !important;
    box-shadow: none !important;
}

/* æ—‹è½¬è§’åº¦æ»‘å—æ ·å¼ */
.rotation-control {
    margin: 5px 0;
    width: 100%;
    padding: 6px 8px;
    background-color: #e6f2ff;
    border-radius: 4px;
    display: flex;
    flex-direction: column;
    align-items: center;
    font-weight: bold;
    color: #1e5b98;
}

.rotation-control label {
    margin-bottom: 5px;
    font-size: 11px;
    text-align: center;
}

#rotationSlider {
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: #d3d3d3;
    outline: none;
    opacity: 0.7;
    transition: opacity 0.2s;
    -webkit-appearance: none;
    appearance: none;
}

#rotationSlider:hover {
    opacity: 1;
}

#rotationSlider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #4c8dbd;
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    transition: all 0.2s ease;
}

#rotationSlider::-webkit-slider-thumb:hover {
    background: #1e5b98;
    transform: scale(1.1);
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
}

#rotationSlider::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #4c8dbd;
    cursor: pointer;
    border: none;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    transition: all 0.2s ease;
}

#rotationSlider::-moz-range-thumb:hover {
    background: #1e5b98;
    transform: scale(1.1);
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
}

/* ç”»ç¬”é¢œè‰²é€‰æ‹©å™¨ */
.pen-options {
    display: none;
    flex-direction: column;
    gap: 8px;
    width: 100%;
    padding: 8px;
    background-color: #e6f2ff;
    border-radius: 4px;
    border: 1px solid #ccc;
    margin: 0;
}

.pen-options.visible {
    display: flex;
}

/* é¢œè‰²é€‰é¡¹å®¹å™¨ - æ¨ªå‘æ’å¸ƒ */
.color-options-container {
    display: flex;
    flex-direction: row;
    justify-content: flex-start;
    align-items: center;
    gap: 6px;
    width: 100%;
    margin-bottom: 8px;
    flex-wrap: wrap;
}

.color-option {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid #ccc;
    transition: transform 0.2s, border-color 0.2s;
    display: block;
    margin: 0;
    flex: 0 0 auto;
}

.color-option:hover {
    transform: scale(1.1);
}

.color-option.selected {
    border-color: #333;
    transform: scale(1.1);
}

.pen-size {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 4px;
    width: 100%;
}

.pen-size label {
    font-size: 11px;
    color: #333;
    margin: 0;
}

.pen-size input {
    width: 100%;
    height: 20px;
}



.message {
    min-height: 50px;
    margin-top: 20px;
    font-size: 1.2rem;
    color: #1e5b98;
    font-weight: bold;
}

.animation {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 100;
    pointer-events: none;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes fadeOut {
    from { opacity: 1; }
    to { opacity: 0; }
}

.fadeIn {
    animation: fadeIn 0.5s forwards;
}

.fadeOut {
    animation: fadeOut 0.5s forwards;
}

@media (max-width: 768px) {
    body {
        overscroll-behavior: none;
        margin: 0;
        padding: 0;
        width: 100%;
        min-height: 100vh;
        overflow-x: hidden;
        transform-origin: top left;
        /* ç¦ç”¨ç”¨æˆ·ç¼©æ”¾æ‰‹åŠ¿ä»¥ä¾¿æ§åˆ¶æ•´ä½“ç¼©æ”¾ */
        touch-action: pan-x pan-y;
    }
    
    .container {
        transform-origin: top center;
        max-width: 900px;
        width: 900px;
        margin: 0 auto;
        /* ä¸æ›´æ”¹å¸ƒå±€ï¼Œåªæ•´ä½“ç¼©æ”¾ */
        transform: scale(0.6);
        padding: 20px;
    }
    
    .canvas-container {
        position: relative;
        margin: 0 auto;
        width: 100%;
        display: flex;
        flex-direction: row; /* ä¿æŒæ°´å¹³å¸ƒå±€ */
        gap: 20px;
        align-items: flex-start;
    }
    
    canvas {
        width: 800px;
        height: 800px;
        touch-action: none;
        /* ä¿æŒåŸå§‹å¤§å°ï¼Œç”±å®¹å™¨æ•´ä½“ç¼©æ”¾ */
    }
    
    .tools {
        display: flex;
        flex-direction: column;
        gap: 15px;
        flex: 0 0 auto;
        width: 130px;
    }
    
    .tool-buttons {
        display: flex;
        flex-direction: column;
        gap: 10px;
        width: 100%;
    }
    
    /* å¢å¤§ç‚¹å‡»åŒºåŸŸï¼Œä½†ä¿æŒè§†è§‰æ ·å¼ä¸€è‡´ */
    button {
        min-height: 44px;
        min-width: 44px;
    }
}

/* Remove styles related to tool icons */
.tools button {
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 5px;
    padding: 8px 12px;
    background-color: #f0f0f0;
    border: 1px solid #ccc;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.3s;
    font-size: 14px;
}
    </style>
</head>
<body>
    <div class="container">
        <h1>AIå›¾å½¢å‰²è¡¥å·¥å…·</h1>
        <div class="canvas-container">
            <canvas id="canvas" width="1120" height="800"></canvas>
            <div class="tools">
                <div class="reset-undo-buttons">
                    <button id="resetBtn">
                        é‡ç½®
                    </button>
                    <button id="undoBtn">
                        æ’¤é”€
                    </button>
                </div>
                <div class="tool-buttons">
                    <button id="scissorsBtn">
                        å‰ªåˆ€å·¥å…·
                    </button>
                    <button id="penBtn">
                        ç”»ç¬”
                    </button>
                    <div class="pen-options">
                        <div class="color-options-container">
                            <div class="color-option selected" data-color="#000000" style="background-color: #000000;"></div>
                            <div class="color-option" data-color="#ff0000" style="background-color: #ff0000;"></div>
                            <div class="color-option" data-color="#0000ff" style="background-color: #0000ff;"></div>
                            <div class="color-option" data-color="#00aa00" style="background-color: #00aa00;"></div>
                        </div>
                        <div class="pen-size">
                            <label for="pen-width">ç¬”è§¦å¤§å°:</label>
                            <input type="range" id="pen-width" min="1" max="20" value="3">
                        </div>
                    </div>
                    <button id="setMainShapeBtn">
                        è®¾ç½®ä¸»ä½“
                    </button>
                    <button id="copyBtn">
                        å¤åˆ¶
                    </button>
                    <button id="deleteBtn">
                        åˆ é™¤
                    </button>
                    <button id="rotateBtn">
                        æ—‹è½¬
                    </button>
                    <div class="rotation-control">
                        <label for="rotationSlider">æ—‹è½¬è§’åº¦: <span id="rotationValue">45</span>Â°</label>
                        <input type="range" id="rotationSlider" min="0" max="90" value="45" step="1">
                    </div>
                    <button id="flipHorizontalBtn">
                        æ°´å¹³ç¿»è½¬
                    </button>
                    <button id="gridBtn" class="active">
                        ç½‘æ ¼
                    </button>
                    <button id="finishDrawingBtn" style="display: none;">
                        ç»“æŸç»˜åˆ¶
                    </button>
                </div>
                
                <div class="cut-direction">
                    <label for="cutModeSelect">è£åˆ‡æ–¹å‘ï¼š</label>
                    <select id="cutModeSelect">
                        <option value="free" selected>è‡ªç”±</option>
                        <option value="vertical">å‚ç›´</option>
                        <option value="horizontal">æ°´å¹³</option>
                    </select>
                </div>
                
                <div class="shape-selection">
                    <label for="shapeSelect">å›¾å½¢é€‰æ‹©ï¼š</label>
                    <select id="shapeSelect">
                        <option value="parallelogram" selected>å¹³è¡Œå››è¾¹å½¢</option>
                        <option value="triangle">ä¸‰è§’å½¢</option>
                        <option value="trapezoid">æ¢¯å½¢</option>
                        <option value="square">æ­£æ–¹å½¢</option>
                        <option value="rectangle">é•¿æ–¹å½¢</option>
                        <option value="circle">åœ†å½¢</option>
                        <option value="custom">è‡ªå®šä¹‰</option>
                    </select>
                </div>
                
                <div class="grid-size-selection">
                    <label for="gridSizeSelect">ç½‘æ ¼å¤§å°ï¼š</label>
                    <select id="gridSizeSelect">
                        <option value="40">40</option>
                        <option value="60">60</option>
                        <option value="80" selected>80</option>
                    </select>
                </div>
                

            </div>
        </div>
        <div id="message" class="message"></div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const resetBtn = document.getElementById('resetBtn');
    const messageEl = document.getElementById('message');

    const scissorsBtn = document.getElementById('scissorsBtn');
    const penBtn = document.getElementById('penBtn');

    const gridBtn = document.getElementById('gridBtn');
    const cutModeSelect = document.getElementById('cutModeSelect');
    const shapeSelect = document.getElementById('shapeSelect');
    const gridSizeSelect = document.getElementById('gridSizeSelect');
    const penOptions = document.querySelector('.pen-options');
    const colorOptions = document.querySelectorAll('.color-option');
    const penWidthInput = document.getElementById('pen-width');
    const rotateBtn = document.getElementById('rotateBtn');
    const flipHorizontalBtn = document.getElementById('flipHorizontalBtn');
    const setMainShapeBtn = document.getElementById('setMainShapeBtn');
    const copyBtn = document.getElementById('copyBtn');
    const deleteBtn = document.getElementById('deleteBtn');
    const undoBtn = document.getElementById('undoBtn');
    const finishDrawingBtn = document.getElementById('finishDrawingBtn');
    
    // ç§»åŠ¨è®¾å¤‡æ£€æµ‹
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    // è®¾ç½®ç”»å¸ƒå›ºå®šå°ºå¯¸ï¼ˆ800x800ï¼‰
    function setupCanvas() {
        // æ— è®ºè®¾å¤‡ç±»å‹ï¼Œéƒ½ä¿æŒç”»å¸ƒå¤§å°ä¸€è‡´
        canvas.width = 1120;
        canvas.height = 800;
    }
    
    // åˆå§‹åŒ–æ—¶è®¾ç½®ç”»å¸ƒå°ºå¯¸
    setupCanvas();
    
    // è°ƒè¯•æ—¥å¿—å‡½æ•°
    function debug(message) {
        console.log(`[DEBUG] ${message}`);
    }
    
    // åˆå§‹åŒ–è£å‰ªå½¢çŠ¶æ•°ç»„
    window.clippedShapes = [];
    
    // çŠ¶æ€å˜é‡
    let isDrawing = false;
    let startPoint = { x: 0, y: 0 };
    let endPoint = { x: 0, y: 0 };
    let parallelogram = null;
    let cuttingLine = null;
    let currentShape = null;

    let cutCount = 0; // è£åˆ‡æ¬¡æ•°è®¡æ•°
    const MAX_CUTS = 5; // æœ€å¤§è£åˆ‡æ¬¡æ•°
    let cutMode = 'free'; // é»˜è®¤ä¸ºè‡ªç”±è£åˆ‡æ¨¡å¼
    let currentShapeType = 'parallelogram'; // é»˜è®¤å½¢çŠ¶ä¸ºå¹³è¡Œå››è¾¹å½¢
    
    // è·å–å½“å‰ç½‘æ ¼å¤§å°
    function getCurrentGridSize() {
        return parseInt(gridSizeSelect.value) || 80;
    }
    
    // æ‹–åŠ¨çŠ¶æ€
    let isDragging = false;
    let draggedShapeIndex = -1;
    let dragStartX = 0;
    let dragStartY = 0;
    
    // å½“å‰é€‰ä¸­çš„å›¾å½¢ç´¢å¼•
    let selectedShapeIndex = -1;
    
    // å›¾å½¢é€‰ä¸­çŠ¶æ€ç®¡ç†
    let isShapeSelected = false;
    let selectedShape = null;
    
    // ç”»ç¬”è®¾ç½®
    let currentTool = 'none'; // 'scissors', 'pen' æˆ– 'none'
    let isPenDrawing = false;
    let penColor = '#000000';
    let penWidth = 3;
    let penStrokes = []; // å­˜å‚¨æ‰€æœ‰ç”»ç¬”ç¬”ç”»
    let currentStroke = null; // å½“å‰æ­£åœ¨ç»˜åˆ¶çš„ç¬”ç”»
    
    // ç½‘æ ¼è®¾ç½®
    let showGrid = true;
    
    // å¸é™„è·ç¦»ï¼ˆåƒç´ ï¼‰
    const SNAP_DISTANCE = 20; // å¢åŠ å¸é™„è·ç¦»ï¼Œæé«˜é¡¶ç‚¹è¯†åˆ«æˆåŠŸç‡
    
    // è‡ªå®šä¹‰å›¾å½¢ç»˜åˆ¶çŠ¶æ€
    let isDrawingCustomShape = false;
    let customShapeVertices = [];
    let tempCustomVertex = null;
    
    // å†å²è®°å½•ç›¸å…³å˜é‡
    let stateHistory = [];
    const MAX_HISTORY = 10; // æœ€å¤§å†å²è®°å½•æ•°é‡
    
    // åˆå§‹åŒ–
    initCanvas();
    
    // å·¥å…·åˆ‡æ¢äº‹ä»¶
    scissorsBtn.addEventListener('click', () => {
        // å¦‚æœå½“å‰å·²ç»æ˜¯å‰ªåˆ€å·¥å…·ï¼Œåˆ™å–æ¶ˆæ¿€æ´»ï¼›å¦åˆ™æ¿€æ´»å‰ªåˆ€å·¥å…·
        setCurrentTool(currentTool === 'scissors' ? 'none' : 'scissors');
    });
    
    penBtn.addEventListener('click', () => {
        // å¦‚æœå½“å‰å·²ç»æ˜¯ç”»ç¬”å·¥å…·ï¼Œåˆ™å–æ¶ˆæ¿€æ´»ï¼›å¦åˆ™æ¿€æ´»ç”»ç¬”å·¥å…·
        setCurrentTool(currentTool === 'pen' ? 'none' : 'pen');
    });
    

    
    // æ—‹è½¬æŒ‰é’®äº‹ä»¶
    rotateBtn.addEventListener('click', () => {
        // å‰ªåˆ€å·¥å…·çŠ¶æ€ä¸‹ç¦ç”¨æ—‹è½¬åŠŸèƒ½
        if (currentTool === 'scissors') {
            messageEl.textContent = 'è¯·å…ˆå–æ¶ˆå‰ªåˆ€å·¥å…·ï¼Œç„¶åå†è¿›è¡Œæ—‹è½¬æ“ä½œ';
            setTimeout(() => {
                if (messageEl.textContent === 'è¯·å…ˆå–æ¶ˆå‰ªåˆ€å·¥å…·ï¼Œç„¶åå†è¿›è¡Œæ—‹è½¬æ“ä½œ') {
                    messageEl.textContent = '';
                }
            }, 2000);
            return;
        }
        rotateClippedShape();
    });
    
    // æ—‹è½¬è§’åº¦æ»‘å—äº‹ä»¶
    const rotationSlider = document.getElementById('rotationSlider');
    const rotationValue = document.getElementById('rotationValue');
    if (rotationSlider && rotationValue) {
        rotationSlider.addEventListener('input', () => {
            rotationValue.textContent = rotationSlider.value;
        });
    }
    
    // æ°´å¹³ç¿»è½¬æŒ‰é’®äº‹ä»¶
    flipHorizontalBtn.addEventListener('click', () => {
        // å‰ªåˆ€å·¥å…·çŠ¶æ€ä¸‹ç¦ç”¨ç¿»è½¬åŠŸèƒ½
        if (currentTool === 'scissors') {
            messageEl.textContent = 'è¯·å…ˆå–æ¶ˆå‰ªåˆ€å·¥å…·ï¼Œç„¶åå†è¿›è¡Œç¿»è½¬æ“ä½œ';
            setTimeout(() => {
                if (messageEl.textContent === 'è¯·å…ˆå–æ¶ˆå‰ªåˆ€å·¥å…·ï¼Œç„¶åå†è¿›è¡Œç¿»è½¬æ“ä½œ') {
                    messageEl.textContent = '';
                }
            }, 2000);
            return;
        }
        flipHorizontalShape();
    });
    
    // è®¾ç½®ä¸»ä½“æŒ‰é’®äº‹ä»¶
    setMainShapeBtn.addEventListener('click', () => {
        if (!setMainShapeBtn.disabled) {
            setMainShape();
        }
    });
    
    // å¤åˆ¶æŒ‰é’®äº‹ä»¶
    copyBtn.addEventListener('click', () => {
        if (!copyBtn.disabled) {
            copySelectedShape();
        }
    });
    
    // åˆ é™¤æŒ‰é’®äº‹ä»¶
    deleteBtn.addEventListener('click', () => {
        if (!deleteBtn.disabled) {
            deleteSelectedShape();
        }
    });
    
    // æ’¤é”€æŒ‰é’®äº‹ä»¶
    undoBtn.addEventListener('click', () => {
        undoLastAction();
    });
    
    // ç½‘æ ¼åˆ‡æ¢äº‹ä»¶
    gridBtn.addEventListener('click', () => {
        if (!gridBtn.disabled) {
            showGrid = !showGrid;
            gridBtn.classList.toggle('active', showGrid);
            drawShape();
        }
    });
    
    // è£åˆ‡æ¨¡å¼å˜æ›´äº‹ä»¶
    cutModeSelect.addEventListener('change', () => {
        cutMode = cutModeSelect.value;
    });
    
    // å›¾å½¢é€‰æ‹©å˜æ›´äº‹ä»¶
    shapeSelect.addEventListener('change', () => {
        currentShapeType = shapeSelect.value;
        
        if (currentShapeType === 'custom') {
            // å¯åŠ¨è‡ªå®šä¹‰å›¾å½¢ç»˜åˆ¶æ¨¡å¼
            startCustomShapeDrawing();
        } else {
            // åˆ‡æ¢å›¾å½¢æ—¶å…ˆæ¸…ç†ç”»å¸ƒä¸­çš„æ‰€æœ‰å›¾å½¢
            // æ¸…ç©ºä¸»å›¾å½¢
            currentShape = null;
            
            // æ¸…ç©ºæ‰€æœ‰è£åˆ‡å›¾å½¢
            window.clippedShapes = [];
            
            // æ¸…ç©ºæ‰€æœ‰ç”»ç¬”ç¬”ç”»
            penStrokes = [];
            currentStroke = null;
            isPenDrawing = false;
            
            // æ¸…ç©ºè‡ªå®šä¹‰å›¾å½¢ç»˜åˆ¶çŠ¶æ€
            customShapeVertices = [];
            tempCustomVertex = null;
            isDrawingCustomShape = false;
            
            // é‡ç½®é€‰ä¸­çŠ¶æ€
            selectedShapeIndex = -1;
            isShapeSelected = false;
            selectedShape = null;
            
            // é‡ç½®è£åˆ‡è®¡æ•°
            cutCount = 0;
            
            // é‡ç½®è‡ªå®šä¹‰å›¾å½¢çŠ¶æ€
            resetCustomShapeDrawing();
            // é‡ç½®å·¥å…·çŠ¶æ€ä¸ºé»˜è®¤ï¼ˆæ— å·¥å…·é€‰ä¸­ï¼‰
            setCurrentTool('none');
            handleReset(); // é‡ç½®å¹¶é‡æ–°ç»˜åˆ¶æ‰€é€‰å›¾å½¢
        }
    });
    
    // ç½‘æ ¼å¤§å°é€‰æ‹©å˜æ›´äº‹ä»¶
    gridSizeSelect.addEventListener('change', () => {
        // åˆ‡æ¢ç½‘æ ¼æ—¶æ¸…é™¤æ‰€æœ‰å›¾å½¢
        // æ¸…ç©ºä¸»å›¾å½¢
        currentShape = null;
        
        // æ¸…ç©ºæ‰€æœ‰è£åˆ‡å›¾å½¢
        window.clippedShapes = [];
        
        // æ¸…ç©ºæ‰€æœ‰ç”»ç¬”ç¬”ç”»
        penStrokes = [];
        currentStroke = null;
        isPenDrawing = false;
        
        // æ¸…ç©ºè‡ªå®šä¹‰å›¾å½¢ç»˜åˆ¶çŠ¶æ€
        customShapeVertices = [];
        tempCustomVertex = null;
        isDrawingCustomShape = false;
        
        // é‡ç½®è£åˆ‡æ¬¡æ•°
        cutCount = 0;
        
        // é‡ç½®é€‰ä¸­çŠ¶æ€
        selectedShapeIndex = -1;
        isShapeSelected = false;
        selectedShape = null;
        
        // é‡ç½®æ‹–åŠ¨çŠ¶æ€
        isDragging = false;
        draggedShapeIndex = -1;
        dragStartX = 0;
        dragStartY = 0;
        
        // é‡ç½®ç”»ç¬”çŠ¶æ€
        isPenDrawing = false;
        currentStroke = null;
        
        // é‡ç½®è‡ªå®šä¹‰å›¾å½¢çŠ¶æ€
        isDrawingCustomShape = false;
        customShapeVertices = [];
        tempCustomVertex = null;
        
        // éšè—å®Œæˆç»˜åˆ¶æŒ‰é’®
        finishDrawingBtn.style.display = 'none';
        
        // é‡ç½®å·¥å…·çŠ¶æ€
        setCurrentTool('none');
        
        // éšè—ç»“æŸç»˜åˆ¶æŒ‰é’®
        finishDrawingBtn.style.display = 'none';
        
        // æ¸…ç©ºå†å²è®°å½•
        stateHistory = [];
        
        // é‡æ–°ç»˜åˆ¶ï¼ˆåªæ˜¾ç¤ºç½‘æ ¼ï¼‰
        drawShape();
        
        // æ›´æ–°æŒ‰é’®çŠ¶æ€
        updateScissorsState();
        updateUndoButton();
        
        // æ˜¾ç¤ºæç¤ºä¿¡æ¯
        messageEl.textContent = 'å·²åˆ‡æ¢ç½‘æ ¼å¤§å°å¹¶æ¸…é™¤æ‰€æœ‰å›¾å½¢';
        setTimeout(() => {
            if (messageEl.textContent === 'å·²åˆ‡æ¢ç½‘æ ¼å¤§å°å¹¶æ¸…é™¤æ‰€æœ‰å›¾å½¢') {
                messageEl.textContent = '';
            }
        }, 2000);
    });
    
    // è®¾ç½®å½“å‰å·¥å…·
    function setCurrentTool(tool) {
        currentTool = tool;
        
        // æ›´æ–°æŒ‰é’®çŠ¶æ€
        scissorsBtn.classList.toggle('active', tool === 'scissors');
        penBtn.classList.toggle('active', tool === 'pen');
        
        // æ˜¾ç¤º/éšè—ç”»ç¬”é€‰é¡¹
        penOptions.classList.toggle('visible', tool === 'pen');
        
        // å‰ªåˆ€å·¥å…·çŠ¶æ€ä¸‹çš„è‡ªåŠ¨é€‰ä¸­é€»è¾‘
        if (tool === 'scissors') {
            // æ¿€æ´»å‰ªåˆ€å·¥å…·æ—¶è‡ªåŠ¨é€‰ä¸­ä¸»ä½“å›¾å½¢
            selectedShape = 'main';
            isShapeSelected = true;
            selectedShapeIndex = -1; // å–æ¶ˆè£åˆ‡éƒ¨åˆ†çš„é€‰ä¸­
            messageEl.textContent = 'å·²é€‰ä¸­ä¸»ä½“å›¾å½¢ï¼Œå¯ä»¥å¼€å§‹è£åˆ‡æ“ä½œ';
            setTimeout(() => {
                if (messageEl.textContent === 'å·²é€‰ä¸­ä¸»ä½“å›¾å½¢ï¼Œå¯ä»¥å¼€å§‹è£åˆ‡æ“ä½œ') {
                    messageEl.textContent = '';
                }
            }, 2000);
        } else if (currentTool === 'scissors' && tool !== 'scissors') {
            // å–æ¶ˆå‰ªåˆ€å·¥å…·æ—¶è‡ªåŠ¨å–æ¶ˆé€‰ä¸­çŠ¶æ€
            selectedShape = null;
            isShapeSelected = false;
            selectedShapeIndex = -1;
        }
        
        // æ›´æ–°é¼ æ ‡æ ·å¼
        if (tool === 'scissors') {
            canvas.style.cursor = 'crosshair';
        } else if (tool === 'pen') {
            canvas.style.cursor = 'url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'24\' height=\'24\' viewBox=\'0 0 24 24\'%3E%3Cpath d=\'M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z\'/%3E%3C/svg%3E") 0 24, auto';
        } else {
            canvas.style.cursor = 'default';
        }
        
        // é‡æ–°ç»˜åˆ¶ä»¥æ˜¾ç¤ºé€‰ä¸­çŠ¶æ€çš„å˜åŒ–
        drawShape();
    }
    
    // é¢œè‰²é€‰æ‹©äº‹ä»¶
    colorOptions.forEach(option => {
        option.addEventListener('click', () => {
            // ç§»é™¤ä¹‹å‰çš„é€‰ä¸­çŠ¶æ€
            document.querySelector('.color-option.selected').classList.remove('selected');
            // æ·»åŠ æ–°çš„é€‰ä¸­çŠ¶æ€
            option.classList.add('selected');
            // æ›´æ–°ç”»ç¬”é¢œè‰²
            penColor = option.getAttribute('data-color');
        });
    });
    
    // ç”»ç¬”å¤§å°æ›´æ”¹äº‹ä»¶
    penWidthInput.addEventListener('input', () => {
        penWidth = parseInt(penWidthInput.value);
    });
    
    // äº‹ä»¶ç›‘å¬
    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseup', handleMouseUp);
    canvas.addEventListener('mouseleave', handleMouseLeave);
    resetBtn.addEventListener('click', handleReset);
    finishDrawingBtn.addEventListener('click', handleFinishDrawing);
    
    // è§¦æ‘¸äº‹ä»¶ç›‘å¬ï¼ˆé’ˆå¯¹ç§»åŠ¨è®¾å¤‡ï¼‰
    canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
    canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
    canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
    canvas.addEventListener('touchcancel', handleTouchEnd, { passive: false });
    
    // ç§»åŠ¨è®¾å¤‡ä¸Šçš„æŒ‰é’®ä¹Ÿæ·»åŠ è§¦æ‘¸äº‹ä»¶
    if (isMobile) {
        // æ·»åŠ è§¦æ‘¸äº‹ä»¶ä»¥é˜²æ­¢å»¶è¿Ÿ
        resetBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleReset();
        });
        
        scissorsBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            setCurrentTool('scissors');
        });
        
        penBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            setCurrentTool('pen');
        });
        
        rotateBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            // å‰ªåˆ€å·¥å…·çŠ¶æ€ä¸‹ç¦ç”¨æ—‹è½¬åŠŸèƒ½
            if (currentTool === 'scissors') {
                messageEl.textContent = 'è¯·å…ˆå–æ¶ˆå‰ªåˆ€å·¥å…·ï¼Œç„¶åå†è¿›è¡Œæ—‹è½¬æ“ä½œ';
                setTimeout(() => {
                    if (messageEl.textContent === 'è¯·å…ˆå–æ¶ˆå‰ªåˆ€å·¥å…·ï¼Œç„¶åå†è¿›è¡Œæ—‹è½¬æ“ä½œ') {
                        messageEl.textContent = '';
                    }
                }, 2000);
                return;
            }
            rotateClippedShape();
        });
        
        flipHorizontalBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            // å‰ªåˆ€å·¥å…·çŠ¶æ€ä¸‹ç¦ç”¨ç¿»è½¬åŠŸèƒ½
            if (currentTool === 'scissors') {
                messageEl.textContent = 'è¯·å…ˆå–æ¶ˆå‰ªåˆ€å·¥å…·ï¼Œç„¶åå†è¿›è¡Œç¿»è½¬æ“ä½œ';
                setTimeout(() => {
                    if (messageEl.textContent === 'è¯·å…ˆå–æ¶ˆå‰ªåˆ€å·¥å…·ï¼Œç„¶åå†è¿›è¡Œç¿»è½¬æ“ä½œ') {
                        messageEl.textContent = '';
                    }
                }, 2000);
                return;
            }
            flipHorizontalShape();
        });
        
        gridBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            showGrid = !showGrid;
            gridBtn.classList.toggle('active', showGrid);
            drawShape();
        });
        
        // ä¸ºå›¾å½¢é€‰æ‹©ä¸‹æ‹‰èœå•æ·»åŠ è§¦æ‘¸äº‹ä»¶
        shapeSelect.addEventListener('touchend', (e) => {
            currentShapeType = shapeSelect.value;
            handleReset();
        });
        
        // ä¸ºé¢œè‰²é€‰é¡¹æ·»åŠ è§¦æ‘¸äº‹ä»¶
        colorOptions.forEach(option => {
            option.addEventListener('touchstart', (e) => {
                e.preventDefault();
                document.querySelector('.color-option.selected').classList.remove('selected');
                option.classList.add('selected');
                penColor = option.getAttribute('data-color');
            });
        });
    }
    
    // å¤„ç†é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶
    function handleMouseDown(e) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        debug(`é¼ æ ‡ç‚¹å‡»: x=${mouseX}, y=${mouseY}`);
        
        // å¦‚æœæ­£åœ¨ç»˜åˆ¶è‡ªå®šä¹‰å›¾å½¢
        if (isDrawingCustomShape) {
            handleCustomShapeClick(mouseX, mouseY);
            return;
        }
        
        // å¦‚æœå‰ªåˆ€å·¥å…·æ¿€æ´»ï¼Œç¦ç”¨å›¾å½¢é€‰ä¸­å’Œæ‹–åŠ¨åŠŸèƒ½
        if (currentTool === 'scissors') {
            // å‰ªåˆ€å·¥å…·çŠ¶æ€ä¸‹ï¼Œåªå¤„ç†åˆ‡å‰²æ“ä½œï¼Œä¸å…è®¸é€‰ä¸­å’Œæ‹–åŠ¨
            if (cutCount < MAX_CUTS) {
                isDrawing = true;
                startPoint = { x: mouseX, y: mouseY };
                endPoint = { x: mouseX, y: mouseY };
                cuttingLine = { start: startPoint, end: endPoint };
            }
            return;
        }
        
        // ä¼˜å…ˆæ£€æŸ¥æ˜¯å¦ç‚¹å‡»åœ¨è£åˆ‡éƒ¨åˆ†ä¸Šï¼ˆæœ€ä¸Šå±‚å›¾å½¢ä¼˜å…ˆï¼‰
        debug(`å¼€å§‹æ£€æŸ¥è£åˆ‡å›¾å½¢...`);
        const clickedShapeIndex = getShapeAtPoint(mouseX, mouseY);
        
        if (clickedShapeIndex !== -1) {
            // ä¿å­˜å½“å‰çŠ¶æ€ä»¥æ”¯æŒæ’¤é”€
            saveCurrentState();
            
            // é€‰ä¸­å¹¶å¼€å§‹æ‹–åŠ¨è£åˆ‡éƒ¨åˆ†
            selectedShapeIndex = clickedShapeIndex;
            isShapeSelected = false;
            selectedShape = null;
            isDragging = true;
            draggedShapeIndex = clickedShapeIndex;
            dragStartX = mouseX;
            dragStartY = mouseY;
            canvas.style.cursor = 'move';
            
            debug(`ğŸ¯ æˆåŠŸé€‰ä¸­è£åˆ‡å›¾å½¢ï¼Œç´¢å¼•: ${selectedShapeIndex}`);
            drawShape();
            return;
        } else {
            // å¦‚æœæ²¡æœ‰ç‚¹å‡»åœ¨è£åˆ‡å›¾å½¢ä¸Šï¼Œæ£€æŸ¥æ˜¯å¦ç‚¹å‡»åœ¨ä¸»å›¾å½¢ä¸Š
            debug(`æ£€æŸ¥ä¸»å›¾å½¢: currentShapeå­˜åœ¨=${!!currentShape}, æœ‰é¡¶ç‚¹=${!!(currentShape && currentShape.vertices)}`);
            if (currentShape && currentShape.vertices && isPointInShape(mouseX, mouseY, currentShape)) {
                // ä¿å­˜å½“å‰çŠ¶æ€ä»¥æ”¯æŒæ’¤é”€
                saveCurrentState();
                
                // é€‰ä¸­ä¸»å›¾å½¢
                isShapeSelected = true;
                selectedShape = 'main';
                selectedShapeIndex = -1; // å–æ¶ˆè£åˆ‡éƒ¨åˆ†çš„é€‰ä¸­
                isDragging = true;
                dragStartX = mouseX;
                dragStartY = mouseY;
                canvas.style.cursor = 'move';
                debug(`ğŸ”µ é€‰ä¸­ä¸»å›¾å½¢`);
                drawShape();
                return;
            } else {
                // ç‚¹å‡»ç©ºç™½å¤„ï¼Œå–æ¶ˆæ‰€æœ‰é€‰ä¸­
                selectedShapeIndex = -1;
                isShapeSelected = false;
                selectedShape = null;
                debug(`ç‚¹å‡»ç©ºç™½å¤„ï¼Œå–æ¶ˆæ‰€æœ‰é€‰ä¸­`);
                drawShape();
            }
        }
        
        // æ ¹æ®å½“å‰å·¥å…·æ‰§è¡Œç›¸åº”æ“ä½œ
        if (currentTool === 'scissors' && cutCount < MAX_CUTS) {
            startDrawing(e);
        } else if (currentTool === 'pen') {
            startPenDrawing(e);
        }
    }
    
    // å¤„ç†é¼ æ ‡ç§»åŠ¨äº‹ä»¶
    function handleMouseMove(e) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // æ‹–åŠ¨ä¸»å›¾å½¢
        if (isDragging && isShapeSelected && selectedShape === 'main') {
            const dx = mouseX - dragStartX;
            const dy = mouseY - dragStartY;
            
            // ç§»åŠ¨ä¸»å›¾å½¢çš„æ‰€æœ‰é¡¶ç‚¹
            if (currentShape && currentShape.vertices) {
                for (let i = 0; i < currentShape.vertices.length; i++) {
                    currentShape.vertices[i].x += dx;
                    currentShape.vertices[i].y += dy;
                }
            }
            
            dragStartX = mouseX;
            dragStartY = mouseY;
            
            drawShape();
            return;
        }
        
        // æ‹–åŠ¨è£åˆ‡éƒ¨åˆ†
        if (isDragging && draggedShapeIndex !== -1) {
            const dx = mouseX - dragStartX;
            const dy = mouseY - dragStartY;
            
            // ç§»åŠ¨è¢«æ‹–åŠ¨çš„å½¢çŠ¶çš„æ‰€æœ‰é¡¶ç‚¹
            const shape = window.clippedShapes[draggedShapeIndex];
            for (let i = 0; i < shape.vertices.length; i++) {
                shape.vertices[i].x += dx;
                shape.vertices[i].y += dy;
            }
            
            dragStartX = mouseX;
            dragStartY = mouseY;
            
            drawShape();
            return;
        }
        
        // æ›´æ–°é¼ æ ‡æ ·å¼
        if (!isDragging) {
            const isOverMainShape = currentShape && currentShape.vertices && isPointInShape(mouseX, mouseY, currentShape);
            const isOverClippedShape = getShapeAtPoint(mouseX, mouseY) !== -1;
            
            if (isOverMainShape || isOverClippedShape) {
                canvas.style.cursor = 'move';
            } else if (currentTool === 'scissors') {
                canvas.style.cursor = 'crosshair';
            } else {
                canvas.style.cursor = 'default';
            }
        }
        
        if (currentTool === 'scissors' && isDrawing && cutCount < MAX_CUTS) {
            drawing(e);
        } else if (currentTool === 'pen' && isPenDrawing) {
            penDrawing(e);
        }
    }
    
    // å¤„ç†é¼ æ ‡é‡Šæ”¾äº‹ä»¶
    function handleMouseUp() {
        if (isDragging) {
            isDragging = false;
            // æ‹–åŠ¨ç»“æŸï¼Œä½†ä¿æŒå½“å‰é€‰ä¸­çš„å›¾å½¢ç´¢å¼•ä¸å˜
            draggedShapeIndex = -1;
            
            // æ›´æ–°æ’¤é”€æŒ‰é’®çŠ¶æ€
            updateUndoButton();
            
            // æ¢å¤æ­£å¸¸é¼ æ ‡æ ·å¼
            if (currentTool === 'scissors') {
                canvas.style.cursor = 'crosshair';
            } else {
                canvas.style.cursor = 'url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'24\' height=\'24\' viewBox=\'0 0 24 24\'%3E%3Cpath d=\'M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z\'/%3E%3C/svg%3E") 0 24, auto';
            }
            return;
        }
        
        if (currentTool === 'scissors' && cutCount < MAX_CUTS) {
            endDrawing();
        } else if (currentTool === 'pen') {
            endPenDrawing();
        }
    }
    
    // æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨å½¢çŠ¶å†…éƒ¨
    function isPointInShape(x, y, shape) {
        const vertices = shape.vertices;
        let inside = false;
        
        // æ·»åŠ è°ƒè¯•ä¿¡æ¯
        debug(`  æ£€æµ‹ç‚¹(${x.toFixed(1)}, ${y.toFixed(1)})æ˜¯å¦åœ¨å›¾å½¢å†…ï¼Œé¡¶ç‚¹æ•°: ${vertices.length}`);
        
        for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
            const xi = vertices[i].x, yi = vertices[i].y;
            const xj = vertices[j].x, yj = vertices[j].y;
            
            const intersect = ((yi > y) !== (yj > y)) &&
                (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        
        debug(`  ç»“æœ: ${inside ? 'åœ¨å›¾å½¢å†…' : 'ä¸åœ¨å›¾å½¢å†…'}`);
        return inside;
    }
    
    // è·å–ç‚¹å‡»ä½ç½®ä¸Šçš„å½¢çŠ¶ç´¢å¼•ï¼ˆä¼˜å…ˆé€‰ä¸­æœ€ä¸Šå±‚å›¾å½¢ï¼‰
    function getShapeAtPoint(x, y) {
        if (!window.clippedShapes) return -1;
        
        debug(`ç‚¹å‡»æ£€æŸ¥: (${x.toFixed(1)}, ${y.toFixed(1)}), å›¾å½¢æ€»æ•°: ${window.clippedShapes.length}`);
        
        // ä»æ•°ç»„æœ«å°¾å¼€å§‹éå†ï¼Œä¼˜å…ˆé€‰ä¸­æœ€ä¸Šå±‚ï¼ˆæœ€åç»˜åˆ¶ï¼‰çš„å›¾å½¢
        for (let i = window.clippedShapes.length - 1; i >= 0; i--) {
            if (isPointInShape(x, y, window.clippedShapes[i])) {
                debug(`âœ“ é€‰ä¸­å›¾å½¢ç´¢å¼•: ${i} (åœ¨${window.clippedShapes.length}ä¸ªå›¾å½¢ä¸­çš„æœ€ä¸Šå±‚)`);
                return i;
            }
        }
        
        debug(`âœ— æœªæ‰¾åˆ°åŒ¹é…å›¾å½¢`);
        return -1;
    }
    
    // å¤„ç†é¼ æ ‡ç¦»å¼€äº‹ä»¶
    function handleMouseLeave() {
        isDragging = false;
        
        if (currentTool === 'scissors' && cutCount < MAX_CUTS) {
            endDrawing();
        } else if (currentTool === 'pen') {
            endPenDrawing();
        }
    }
    
    // å¼€å§‹ç”»ç¬”ç»˜åˆ¶
    function startPenDrawing(e) {
        isPenDrawing = true;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // åˆ›å»ºæ–°çš„ç¬”ç”»å¯¹è±¡
        currentStroke = {
            points: [{ x, y }],
            color: penColor,
            width: penWidth
        };
    }
    
    // ç”»ç¬”ç»˜åˆ¶ä¸­
    function penDrawing(e) {
        if (!isPenDrawing || !currentStroke) return;
        
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // æ·»åŠ ç‚¹åˆ°å½“å‰ç¬”ç”»
        currentStroke.points.push({ x, y });
        
        // é‡æ–°ç»˜åˆ¶æ•´ä¸ªç”»å¸ƒ
        drawShape();
    }
    
    // ç»“æŸç”»ç¬”ç»˜åˆ¶
    function endPenDrawing() {
        if (isPenDrawing && currentStroke) {
            // å°†å®Œæˆçš„ç¬”ç”»æ·»åŠ åˆ°ç¬”ç”»æ•°ç»„
            penStrokes.push(currentStroke);
            currentStroke = null;
            // æ›´æ–°æ’¤é”€æŒ‰é’®çŠ¶æ€
            updateUndoButton();
        }
        isPenDrawing = false;
    }
    


    
    // è®¡ç®—å¤šè¾¹å½¢é¢ç§¯
    function calculatePolygonArea(vertices) {
        let area = 0;
        const n = vertices.length;
        
        for (let i = 0; i < n; i++) {
            const j = (i + 1) % n;
            area += vertices[i].x * vertices[j].y;
            area -= vertices[j].x * vertices[i].y;
        }
        
        area = Math.abs(area) / 2;
        return Math.round(area);
    }
    
    // è®¡ç®—å½¢çŠ¶çš„è´¨å¿ƒ
    function calculateCentroid(vertices) {
        let sumX = 0;
        let sumY = 0;
        
        for (const vertex of vertices) {
            sumX += vertex.x;
            sumY += vertex.y;
        }
        
        return {
            x: sumX / vertices.length,
            y: sumY / vertices.length
        };
    }
    

    
    // å‰ªåˆ‡å½¢çŠ¶
    function cut() {
        // å¦‚æœå·²ç»è£åˆ‡è¿‡ï¼Œä¸å…è®¸å†æ¬¡è£åˆ‡
        if (cutCount >= MAX_CUTS) return;
        
        // åœ¨æ‰§è¡Œåˆ‡å‰²å‰ä¿å­˜å½“å‰çŠ¶æ€
        saveCurrentState();
        
        debug(`å¼€å§‹è£åˆ‡æ“ä½œï¼Œå½“å‰å½¢çŠ¶: ${currentShape ? 'æœ‰æ•ˆ' : 'æ— æ•ˆ'}`);
        if (currentShape) {
            debug(`é¡¶ç‚¹æ•°é‡: ${currentShape.vertices.length}, è¾¹æ•°é‡: ${currentShape.edges.length}`);
        }
        debug(`å‰ªåˆ‡çº¿: ${cuttingLine ? JSON.stringify(cuttingLine) : 'æ— æ•ˆ'}`);
        
        // æ‰¾å‡ºå‰ªåˆ‡çº¿ä¸å½¢çŠ¶è¾¹ç¼˜çš„äº¤ç‚¹
        const intersections = findIntersections();
        debug(`æ‰¾åˆ°çš„äº¤ç‚¹æ•°é‡: ${intersections.length}`);
        
        if (intersections.length >= 2) {
            // æ£€æŸ¥æ˜¯å¦æ˜¯å¯¹è§’çº¿åˆ‡å‰²
            const isDiagonalCut = isAlongDiagonal(intersections);
            debug(`æ˜¯å¦å¯¹è§’çº¿åˆ‡å‰²: ${isDiagonalCut}`);
            
            // æ ¹æ®äº¤ç‚¹åˆ†å‰²å½¢çŠ¶ï¼Œè·å–ä¸¤ä¸ªéƒ¨åˆ†
            const {mainShape, cutPiece} = splitShapeImproved(intersections);
            
            // æ›´æ–°å½“å‰å½¢çŠ¶ä¸ºä¸»ä½“éƒ¨åˆ†
            currentShape = mainShape;
            
            // ç¡®ä¿å…¨å±€æ•°ç»„å·²åˆå§‹åŒ–
            if (!window.clippedShapes) {
                window.clippedShapes = [];
            }
            
            // æ·»åŠ è¢«è£å‰ªéƒ¨åˆ†åˆ°åœºæ™¯ä¸­
            window.clippedShapes.push(cutPiece);
            debug(`æ·»åŠ è£åˆ‡éƒ¨åˆ†ï¼Œå½“å‰å…±${window.clippedShapes.length}ä¸ª`);
            
            // æ ‡è®°å·²ç»è£åˆ‡è¿‡
            cutCount++;
            
            // æ›´æ–°å‰ªåˆ€å·¥å…·çŠ¶æ€
            updateScissorsState();
            
            drawShape();
            

            
            // æ£€æŸ¥å½¢çŠ¶æ˜¯å¦æ¥è¿‘é•¿æ–¹å½¢
            checkRectangularShape();
            
            // ç§»é™¤è£åˆ‡åçš„æç¤ºä¿¡æ¯
            
            // æ›´æ–°æ’¤é”€æŒ‰é’®çŠ¶æ€
            updateUndoButton();
        } else {
            debug(`äº¤ç‚¹ä¸è¶³ï¼Œæ— æ³•è£åˆ‡`);
        }
        
        cuttingLine = null;
    }
    
    // æŸ¥æ‰¾å‰ªåˆ‡çº¿ä¸å½¢çŠ¶è¾¹ç¼˜çš„äº¤ç‚¹
    function findIntersections() {
        const intersections = [];
        const vertexIntersections = new Set(); // ç”¨äºè·Ÿè¸ªä¸é¡¶ç‚¹çš„äº¤ç‚¹
        
        // æ£€æŸ¥å½“å‰å½¢çŠ¶æ˜¯å¦æœ‰æ•ˆ
        if (!currentShape || !currentShape.vertices || !currentShape.edges) {
            debug("å½“å‰å½¢çŠ¶æ— æ•ˆï¼Œæ— æ³•æŸ¥æ‰¾äº¤ç‚¹");
            return intersections;
        }
        
        // æ£€æŸ¥è£åˆ‡çº¿æ˜¯å¦æœ‰æ•ˆ
        if (!cuttingLine) {
            debug("è£åˆ‡çº¿æ— æ•ˆï¼Œæ— æ³•æŸ¥æ‰¾äº¤ç‚¹");
            return intersections;
        }
        
        debug(`æŸ¥æ‰¾äº¤ç‚¹ï¼Œå½“å‰å½¢çŠ¶æœ‰ ${currentShape.vertices.length} ä¸ªé¡¶ç‚¹ï¼Œ${currentShape.edges.length} æ¡è¾¹`);
        
        // é¦–å…ˆæ£€æŸ¥å‰ªåˆ‡çº¿æ˜¯å¦ç»è¿‡ä»»ä½•é¡¶ç‚¹
        for (let i = 0; i < currentShape.vertices.length; i++) {
            const vertex = currentShape.vertices[i];
            
            // æ£€æŸ¥é¡¶ç‚¹æ˜¯å¦åœ¨å‰ªåˆ‡çº¿ä¸Šï¼Œä½¿ç”¨æ›´å®½æ¾çš„è·ç¦»æ£€æŸ¥ä»¥æé«˜å¯é æ€§
            const distToLine = distancePointToLine(vertex, cuttingLine.start, cuttingLine.end);
            if (distToLine < 5) { // å¢åŠ åˆ°5åƒç´ çš„è¯¯å·®ï¼Œè¿›ä¸€æ­¥æé«˜æ£€æµ‹æˆåŠŸç‡
                intersections.push({
                    point: { ...vertex },
                    edge: { start: -1, end: -1 },  // ç‰¹æ®Šæ ‡è®°ä¸ºé¡¶ç‚¹
                    isVertex: true,
                    vertexIndex: i
                });
                vertexIntersections.add(i);
                
                // å¦‚æœæœ‰ä¸¤ä¸ªé¡¶ç‚¹äº¤ç‚¹ï¼Œæ— éœ€å†æ£€æŸ¥è¾¹çš„äº¤ç‚¹
                if (intersections.length >= 2) {
                    debug("æ‰¾åˆ°ä¸¤ä¸ªé¡¶ç‚¹äº¤ç‚¹ï¼Œè¿”å›å‰ä¸¤ä¸ªäº¤ç‚¹");
                    return intersections.slice(0, 2);
                }
            }
        }
        
        // å¯¹æ‰€æœ‰å‰ªåˆ‡çº¿è¿›è¡Œå»¶é•¿ï¼Œç¡®ä¿èƒ½æ‰¾åˆ°äº¤ç‚¹ï¼Œæé«˜å¯é æ€§
        // æ— è®ºä»€ä¹ˆåˆ‡å‰²æ¨¡å¼ï¼Œéƒ½å»¶é•¿çº¿æ®µä»¥ç¡®ä¿ä¸å½¢çŠ¶ç›¸äº¤
        extendCutLine();
        
        // ç„¶åæ£€æŸ¥å‰ªåˆ‡çº¿ä¸è¾¹çš„äº¤ç‚¹
        for (const edge of currentShape.edges) {
            const v1 = currentShape.vertices[edge.start];
            const v2 = currentShape.vertices[edge.end];
            
            // å¦‚æœä¸¤ä¸ªé¡¶ç‚¹éƒ½å·²ç»æ˜¯äº¤ç‚¹ï¼Œè·³è¿‡è¿™æ¡è¾¹
            if (vertexIntersections.has(edge.start) && vertexIntersections.has(edge.end)) {
                continue;
            }
            
            // è®¡ç®—å‰ªåˆ‡çº¿ä¸å½“å‰è¾¹çš„äº¤ç‚¹
            const intersection = lineIntersection(
                cuttingLine.start, cuttingLine.end,
                v1, v2
            );
            
            if (intersection) {
                // æ£€æŸ¥äº¤ç‚¹æ˜¯å¦éå¸¸æ¥è¿‘é¡¶ç‚¹ï¼ˆå¦‚æœæ˜¯ï¼Œä¼˜å…ˆä½¿ç”¨é¡¶ç‚¹ï¼‰
                const distToV1 = Math.sqrt(
                    Math.pow(intersection.x - v1.x, 2) + 
                    Math.pow(intersection.y - v1.y, 2)
                );
                
                const distToV2 = Math.sqrt(
                    Math.pow(intersection.x - v2.x, 2) + 
                    Math.pow(intersection.y - v2.y, 2)
                );
                
                if (distToV1 < 5) { // æ›´å®½æ¾çš„é¡¶ç‚¹æ£€æµ‹ï¼Œæé«˜å¯é æ€§
                    if (!vertexIntersections.has(edge.start)) {
                        intersections.push({
                            point: { ...v1 },
                            edge: edge,
                            isVertex: true,
                            vertexIndex: edge.start
                        });
                        vertexIntersections.add(edge.start);
                    }
                } else if (distToV2 < 5) { // æ›´å®½æ¾çš„é¡¶ç‚¹æ£€æµ‹ï¼Œæé«˜å¯é æ€§
                    if (!vertexIntersections.has(edge.end)) {
                        intersections.push({
                            point: { ...v2 },
                            edge: edge,
                            isVertex: true,
                            vertexIndex: edge.end
                        });
                        vertexIntersections.add(edge.end);
                    }
                } else {
                    intersections.push({
                        point: intersection,
                        edge: edge,
                        isVertex: false
                    });
                }
                
                // å¦‚æœæœ‰ä¸¤ä¸ªæˆ–æ›´å¤šäº¤ç‚¹ï¼Œåªè¿”å›å‰ä¸¤ä¸ª
                if (intersections.length >= 2) {
                    debug("å·²æ‰¾åˆ°ä¸¤ä¸ªäº¤ç‚¹ï¼Œè¿”å›å‰ä¸¤ä¸ªäº¤ç‚¹");
                    // ç¡®ä¿æŒ‰ç…§å½¢çŠ¶è½®å»“ä¸Šçš„é¡ºåºæ’åˆ—äº¤ç‚¹
                    return orderIntersectionPoints(intersections.slice(0, 2));
                }
            }
        }
        
        debug(`æœ€ç»ˆæ‰¾åˆ° ${intersections.length} ä¸ªäº¤ç‚¹`);
        // å¦‚æœå°‘äºä¸¤ä¸ªäº¤ç‚¹ï¼Œä¹Ÿéœ€è¦æŒ‰é¡ºåºæ’åˆ—
        return intersections.length > 1 ? orderIntersectionPoints(intersections) : intersections;
    }
    
    // æŒ‰ç…§å½¢çŠ¶è½®å»“ä¸Šçš„é¡ºåºæ’åˆ—äº¤ç‚¹
    function orderIntersectionPoints(points) {
        if (points.length < 2) return points;
        
        // å¯¹äºä¸¤ä¸ªé¡¶ç‚¹äº¤ç‚¹çš„ç®€å•æƒ…å†µï¼ŒæŒ‰é¡¶ç‚¹ç´¢å¼•é¡ºåºæ’åˆ—
        if (points[0].isVertex && points[1].isVertex) {
            const idx0 = points[0].vertexIndex;
            const idx1 = points[1].vertexIndex;
            const N = currentShape.vertices.length;
            
            // è®¡ç®—é¡ºæ—¶é’ˆæ–¹å‘çš„è·ç¦»
            const cwDist = (idx1 >= idx0) ? (idx1 - idx0) : (N + idx1 - idx0);
            // è®¡ç®—é€†æ—¶é’ˆæ–¹å‘çš„è·ç¦»
            const ccwDist = (idx0 >= idx1) ? (idx0 - idx1) : (N + idx0 - idx1);
            
            // é€‰æ‹©è¾ƒçŸ­çš„æ–¹å‘
            if (cwDist <= ccwDist) {
                return [points[0], points[1]];
            } else {
                return [points[1], points[0]];
            }
        }
        
        // ä¸€èˆ¬æƒ…å†µï¼Œæ ¹æ®åœ¨è¾¹ä¸Šçš„ä½ç½®æˆ–é¡¶ç‚¹ç´¢å¼•æ’åº
        // è¿™ä¸ªç®€åŒ–çš„å®ç°å¯èƒ½éœ€è¦æ ¹æ®å…·ä½“åº”ç”¨è¿›è¡Œè°ƒæ•´
        return points;
    }
    
    // å»¶é•¿å‰ªåˆ‡çº¿ï¼Œç¡®ä¿å®ƒç©¿è¿‡æ•´ä¸ªå½¢çŠ¶
    function extendCutLine() {
        // æ£€æŸ¥å½“å‰å½¢çŠ¶æ˜¯å¦æœ‰æ•ˆ
        if (!currentShape || !currentShape.vertices) {
            debug("å½“å‰å½¢çŠ¶æ— æ•ˆï¼Œæ— æ³•å»¶é•¿å‰ªåˆ‡çº¿");
            return;
        }
        
        // è·å–å½¢çŠ¶çš„è¾¹ç•Œ
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        
        for (const vertex of currentShape.vertices) {
            minX = Math.min(minX, vertex.x);
            minY = Math.min(minY, vertex.y);
            maxX = Math.max(maxX, vertex.x);
            maxY = Math.max(maxY, vertex.y);
        }
        
        // æ·»åŠ è¾¹ç•Œä½™é‡
        minX -= 50;
        minY -= 50;
        maxX += 50;
        maxY += 50;
        
        // æ ¹æ®æ¨¡å¼å»¶é•¿çº¿æ®µ
        if (cutMode === 'vertical') {
            // ç«–ç›´çº¿ï¼šä¿æŒxä¸å˜ï¼Œå»¶ä¼¸y
            cuttingLine.start.y = minY;
            cuttingLine.end.y = maxY;
        } else if (cutMode === 'horizontal') {
            // æ°´å¹³çº¿ï¼šä¿æŒyä¸å˜ï¼Œå»¶ä¼¸x
            cuttingLine.start.x = minX;
            cuttingLine.end.x = maxX;
        }
    }
    
    // æ”¹è¿›çš„å½¢çŠ¶åˆ†å‰²å‡½æ•°ï¼Œè¿”å›ä¸»ä½“å’Œåˆ‡ç‰‡ä¸¤ä¸ªéƒ¨åˆ†
    function splitShapeImproved(intersections) {
        if (intersections.length < 2) return { mainShape: currentShape, cutPiece: null };

        const N = currentShape.vertices.length;
        if (N === 0) return { mainShape: currentShape, cutPiece: null };

        // ç‰¹æ®Šæƒ…å†µï¼šå¦‚æœä¸¤ä¸ªäº¤ç‚¹éƒ½æ˜¯é¡¶ç‚¹ä¸”æ˜¯å¯¹è§’çº¿åˆ‡å‰² (ä»…é™å››è¾¹å½¢)
        if (currentShape.vertices.length === 4 && intersections[0].isVertex && intersections[1].isVertex) {
            const idx1 = intersections[0].vertexIndex;
            const idx2 = intersections[1].vertexIndex;
            if (Math.abs(idx1 - idx2) === 2) {
                debug("å•ç‹¬å¤„ç†å¯¹è§’çº¿åˆ‡å‰²ã€‚");
                return handleDiagonalCut(idx1, idx2);
            }
        }
        
        // è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—ç‚¹p1å’Œp2ä¹‹é—´çš„è·ç¦»
        function pointDistance(p1, p2) {
            if (!p1 || !p2) return 0;
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        // è¾…åŠ©å‡½æ•°ï¼šè·å–äº¤ç‚¹åœ¨å‘¨é•¿ä¸Šçš„è¿›åº¦
        function getPerimeterProgress(intersection, verticesList) {
            if (intersection.isVertex) {
                return intersection.vertexIndex;
            } else {
                const edgeStartVertex = verticesList[intersection.edge.start];
                const edgeEndVertex = verticesList[intersection.edge.end];
                const edgeLen = pointDistance(edgeStartVertex, edgeEndVertex);
                if (edgeLen < 1e-6) { // è¾¹é•¿å‡ ä¹ä¸º0
                    return intersection.edge.start;
                }
                const distToStart = pointDistance(edgeStartVertex, intersection.point);
                return intersection.edge.start + (distToStart / edgeLen);
            }
        }

        // è®¡ç®—å¹¶æ’åºäº¤ç‚¹
        let intA_raw = intersections[0];
        let intB_raw = intersections[1];

        const progressA = getPerimeterProgress(intA_raw, currentShape.vertices);
        const progressB = getPerimeterProgress(intB_raw, currentShape.vertices);

        let intA, intB;
        if (progressA <= progressB) {
            intA = intA_raw;
            intB = intB_raw;
        } else {
            intA = intB_raw;
            intB = intA_raw;
        }
        
        debug(`æ’åºåçš„äº¤ç‚¹: intAè¿›åº¦ ${getPerimeterProgress(intA, currentShape.vertices)}, intBè¿›åº¦ ${getPerimeterProgress(intB, currentShape.vertices)}`);

        const mainVertices = [];
        const cutVertices = [];

        // --- æ„å»ºç¬¬ä¸€ä¸ªå¤šè¾¹å½¢ (ä» intA åˆ° intB) ---
        mainVertices.push({...intA.point});
        
        let currentLoopIndex = intA.isVertex ? intA.vertexIndex : intA.edge.start;
        let targetLoopIndex = intB.isVertex ? intB.vertexIndex : intB.edge.start;
        
        let idxToAdd = (currentLoopIndex + 1) % N;
        let safetyCount1 = 0;

        // å¾ªç¯æ·»åŠ ä»intAåˆ°intBä¹‹é—´çš„é¡¶ç‚¹
        while(safetyCount1 < N + 5) { // å®‰å…¨ä¸­æ–­
            safetyCount1++;
            let stopThisPath = false;

            if (idxToAdd === targetLoopIndex) { // åˆ°è¾¾intBçº¿æ®µçš„èµ·ç‚¹
                if (intB.isVertex) { // intBæ˜¯è¿™ä¸ªé¡¶ç‚¹ï¼Œè·¯å¾„åœ¨ä»åŸå§‹åˆ—è¡¨æ·»åŠ å®ƒä¹‹å‰ç»“æŸ
                    stopThisPath = true;
                } else { // intBåœ¨ä»¥targetLoopIndexå¼€å§‹çš„è¾¹ä¸Šã€‚æ·»åŠ è¿™ä¸ªé¡¶ç‚¹ã€‚
                    mainVertices.push({...currentShape.vertices[idxToAdd]});
                    stopThisPath = true;
                }
            } else {
                mainVertices.push({...currentShape.vertices[idxToAdd]});
                idxToAdd = (idxToAdd + 1) % N;
            }

            if (stopThisPath) break;
        }
        
        mainVertices.push({...intB.point});

        // --- æ„å»ºç¬¬äºŒä¸ªå¤šè¾¹å½¢ (ä» intB åˆ° intA) ---
        cutVertices.push({...intB.point});
        
        currentLoopIndex = intB.isVertex ? intB.vertexIndex : intB.edge.start;
        targetLoopIndex = intA.isVertex ? intA.vertexIndex : intA.edge.start;
        
        idxToAdd = (currentLoopIndex + 1) % N;
        let safetyCount2 = 0;

        while(safetyCount2 < N + 5) { // å®‰å…¨ä¸­æ–­
            safetyCount2++;
            let stopThisPath = false;

            if (idxToAdd === targetLoopIndex) {
                if (intA.isVertex) {
                    stopThisPath = true;
                } else {
                    cutVertices.push({...currentShape.vertices[idxToAdd]});
                    stopThisPath = true;
                }
            } else {
                cutVertices.push({...currentShape.vertices[idxToAdd]});
                idxToAdd = (idxToAdd + 1) % N;
            }

            if (stopThisPath) break;
        }
        
        cutVertices.push({...intA.point});

        // ç”Ÿæˆå½¢çŠ¶è¾¹
        function generateShapeEdges(vertices) {
            const edges = [];
            for (let i = 0; i < vertices.length; i++) {
                edges.push({
                    start: i,
                    end: (i + 1) % vertices.length
                });
            }
            return edges;
        }

        const mainShape = {
            vertices: mainVertices,
            edges: generateShapeEdges(mainVertices)
        };

        const cutPiece = {
            vertices: cutVertices,
            edges: generateShapeEdges(cutVertices),
            shapeType: currentShapeType
        };

        // æ ¹æ®é¢ç§¯ç¡®å®šä¸»ä½“å’Œåˆ‡ç‰‡
        const mainArea = calculatePolygonArea(mainVertices);
        const cutArea = calculatePolygonArea(cutVertices);
        
        debug(`ä¸»ä½“é¢ç§¯: ${mainArea.toFixed(2)}, åˆ‡ç‰‡é¢ç§¯: ${cutArea.toFixed(2)}`);

        // å¦‚æœé¡¶ç‚¹æ•°ä¸è¶³ï¼Œè¿”å›åŸå½¢çŠ¶
        if (mainVertices.length < 3 || cutVertices.length < 3) {
            debug("è­¦å‘Šï¼šåˆ†å‰²åçš„å½¢çŠ¶é¡¶ç‚¹æ•°ä¸è¶³ï¼Œè¿”å›åŸå½¢çŠ¶");
            return { mainShape: currentShape, cutPiece: null };
        }

        // é€šå¸¸è¾ƒå¤§çš„éƒ¨åˆ†ä½œä¸ºä¸»ä½“ï¼Œè¾ƒå°çš„éƒ¨åˆ†ä½œä¸ºåˆ‡ç‰‡
        if (mainArea >= cutArea) {
            return { mainShape, cutPiece };
        } else {
            return { mainShape: cutPiece, cutPiece: mainShape };
        }
    }
    
    // å¤„ç†å¯¹è§’çº¿åˆ‡å‰²
    function handleDiagonalCut(idx1, idx2) {
        // åˆ›å»ºä¸¤ä¸ªä¸‰è§’å½¢
        const vertices = currentShape.vertices;
        
        // ç¬¬ä¸€ä¸ªä¸‰è§’å½¢ï¼ˆä¸»ä½“å½¢çŠ¶ï¼‰
        const triangle1Vertices = [
            { ...vertices[idx1] },
            { ...vertices[(idx1 + 1) % 4] },
            { ...vertices[idx2] }
        ];
        
        // ç¬¬äºŒä¸ªä¸‰è§’å½¢ï¼ˆåˆ‡ç‰‡ï¼‰
        const triangle2Vertices = [
            { ...vertices[idx1] },
            { ...vertices[(idx1 + 3) % 4] },
            { ...vertices[idx2] }
        ];
        
        // åˆ›å»ºè¾¹
        const triangle1Edges = [
            { start: 0, end: 1 },
            { start: 1, end: 2 },
            { start: 2, end: 0 }
        ];
        
        const triangle2Edges = [
            { start: 0, end: 1 },
            { start: 1, end: 2 },
            { start: 2, end: 0 }
        ];
        
        const mainShape = {
            vertices: triangle1Vertices,
            edges: triangle1Edges
        };
        
        const cutPiece = {
            vertices: triangle2Vertices,
            edges: triangle2Edges,
            shapeType: currentShapeType
        };
        
        return { mainShape, cutPiece };
    }
    
    // æ›´æ–°å‰ªåˆ€å·¥å…·çŠ¶æ€
    function updateScissorsState() {
        if (cutCount >= MAX_CUTS) {
            scissorsBtn.classList.add('disabled');
            scissorsBtn.title = "å·²è¾¾åˆ°æœ€å¤§è£åˆ‡æ¬¡æ•°é™åˆ¶ï¼ˆ" + MAX_CUTS + "æ¬¡ï¼‰";
        } else {
            scissorsBtn.classList.remove('disabled');
            scissorsBtn.title = "";
        }
    }
    
    // æ£€æŸ¥å½¢çŠ¶æ˜¯å¦æ¥è¿‘é•¿æ–¹å½¢
    function checkRectangularShape() {
        if (currentShape.vertices.length !== 4) return;
        
        // è®¡ç®—æ¯æ¡è¾¹çš„æ–¹å‘è§’åº¦
        const angles = [];
        for (let i = 0; i < 4; i++) {
            const current = currentShape.vertices[i];
            const next = currentShape.vertices[(i + 1) % 4];
            const angle = Math.atan2(next.y - current.y, next.x - current.x) * 180 / Math.PI;
            angles.push((angle + 360) % 180); // å½’ä¸€åŒ–åˆ°0-180åº¦
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰ä¸¤ç»„å¹³è¡Œçº¿ï¼ˆè¿‘ä¼¼ï¼‰
        const isParallel1 = Math.abs(angles[0] - angles[2]) < 5; // å®¹å·®5åº¦
        const isParallel2 = Math.abs(angles[1] - angles[3]) < 5;
        
        // æ£€æŸ¥æ˜¯å¦æœ‰ä¸¤ç»„ç›´è§’ï¼ˆè¿‘ä¼¼ï¼‰
        const angleDiff1 = Math.abs(((angles[0] - angles[1]) + 180) % 180 - 90);
        const angleDiff2 = Math.abs(((angles[1] - angles[2]) + 180) % 180 - 90);
        const angleDiff3 = Math.abs(((angles[2] - angles[3]) + 180) % 180 - 90);
        const angleDiff4 = Math.abs(((angles[3] - angles[0]) + 180) % 180 - 90);
        
        const hasRightAngles = angleDiff1 < 10 && angleDiff2 < 10 && angleDiff3 < 10 && angleDiff4 < 10;
        
        // å¦‚æœæ‹–åŠ¨åå½¢æˆäº†é•¿æ–¹å½¢ï¼Œæ£€æŸ¥è¢«è£åˆ‡éƒ¨åˆ†æ˜¯å¦å·²ç»æ¥è¿‘ä¸»ä½“è¾¹ç¼˜
        if (isParallel1 && isParallel2 && hasRightAngles && window.clippedShapes.length > 0) {
            // è·å–è¢«è£åˆ‡éƒ¨åˆ†
            const clippedShape = window.clippedShapes[0];
            
            // æ£€æŸ¥æ˜¯å¦æœ‰ä¸€ä¸ªè¾¹ç¼˜æ¥è¿‘ä¸»ä½“
            let isNearMainShape = false;
            
            // æ£€æŸ¥è£åˆ‡éƒ¨åˆ†çš„æ¯ä¸ªé¡¶ç‚¹åˆ°ä¸»ä½“å½¢çŠ¶è¾¹ç¼˜çš„æœ€å°è·ç¦»
            for (const vertex of clippedShape.vertices) {
                let minDist = Number.MAX_VALUE;
                
                // æ£€æŸ¥åˆ°æ¯æ¡è¾¹çš„è·ç¦»
                for (let i = 0; i < currentShape.vertices.length; i++) {
                    const start = currentShape.vertices[i];
                    const end = currentShape.vertices[(i + 1) % currentShape.vertices.length];
                    
                    const dist = distancePointToLine(vertex, start, end);
                    minDist = Math.min(minDist, dist);
                }
                
                // å¦‚æœæœ‰ä¸€ä¸ªé¡¶ç‚¹éå¸¸æ¥è¿‘ä¸»ä½“è¾¹ç¼˜
                if (minDist < 10) { // å®¹å·®10åƒç´ 
                    isNearMainShape = true;
                    break;
                }
            }
            
            // å¦‚æœå½¢æˆäº†é•¿æ–¹å½¢ä¸”ä¸¤ä¸ªéƒ¨åˆ†æ¥è¿‘
            if (isNearMainShape) {
                // ç§»é™¤æˆåŠŸæç¤ºä¿¡æ¯
            }
        }
    }
    
    // ç»˜åˆ¶è¢«è£å‰ªçš„å½¢çŠ¶ï¼ˆé¢œè‰²å›ºå®šï¼‰
    function drawClippedShape(shape, index) {
        // æ˜¯å¦é€‰ä¸­å½“å‰å›¾å½¢
        const isSelected = (index === selectedShapeIndex);
        debug(`ç»˜åˆ¶å›¾å½¢ ${index}, æ˜¯å¦é€‰ä¸­: ${isSelected}`);
        
        ctx.beginPath();
        ctx.moveTo(shape.vertices[0].x, shape.vertices[0].y);
        
        for (let i = 1; i < shape.vertices.length; i++) {
            ctx.lineTo(shape.vertices[i].x, shape.vertices[i].y);
        }
        
        ctx.closePath();
        
        // å¦‚æœæ˜¯é€‰ä¸­çš„å›¾å½¢ï¼Œä½¿ç”¨ä¸åŒçš„å¡«å……è‰²
        if (isSelected) {
            ctx.fillStyle = 'rgba(255, 200, 200, 0.95)'; // é€‰ä¸­çš„å›¾å½¢ä½¿ç”¨åçº¢è‰²
            ctx.fill();
            ctx.strokeStyle = '#ff3333'; // é€‰ä¸­çš„å›¾å½¢ä½¿ç”¨çº¢è‰²è¾¹æ¡†
            ctx.lineWidth = 3;
            ctx.stroke();
        } else {
            // ä½¿ç”¨ä¸ä¸»ä½“éƒ¨åˆ†ç›¸åŒçš„æ ·å¼
            ctx.fillStyle = 'rgba(230, 242, 255, 0.5)'; // æ›´é«˜çš„ä¸é€æ˜åº¦ï¼Œæ”¹ä¸ºè“è‰²ç³»
            ctx.fill();
            ctx.strokeStyle = '#1e5b98';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        // ç»˜åˆ¶é¡¶ç‚¹ï¼ˆåœ†å½¢é™¤å¤–ï¼‰
        if (shape.shapeType !== 'circle') {
            ctx.fillStyle = '#4c8dbd'; // ä¸ä¸»ä½“éƒ¨åˆ†é¡¶ç‚¹ç›¸åŒçš„é¢œè‰²
            shape.vertices.forEach(vertex => {
                ctx.beginPath();
                ctx.arc(vertex.x, vertex.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }
    }
    
    // ç»˜åˆ¶æ‰€æœ‰è£å‰ªçš„éƒ¨åˆ†
    function drawAllClippedShapes() {
        if (!window.clippedShapes || window.clippedShapes.length === 0) {
            return;
        }
        
        debug(`ğŸ“Š ç»˜åˆ¶${window.clippedShapes.length}ä¸ªå›¾å½¢ï¼Œå½“å‰é€‰ä¸­: ${selectedShapeIndex}ï¼Œæœ€ä¸Šå±‚ç´¢å¼•: ${window.clippedShapes.length - 1}`);
        
        // ç›´æ¥ç»˜åˆ¶æ‰€æœ‰è£å‰ªå½¢çŠ¶ï¼ˆç´¢å¼•è¶Šå¤§çš„å›¾å½¢è¶Šåœ¨ä¸Šå±‚ï¼‰
        for (let i = 0; i < window.clippedShapes.length; i++) {
            drawClippedShape(window.clippedShapes[i], i);
        }
    }
    
    // ç»˜åˆ¶æ‰€æœ‰å½¢çŠ¶å’Œå…ƒç´ 
    function drawShape() {
        // æ¸…ç©ºç”»å¸ƒ
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // å¦‚æœå¼€å¯äº†ç½‘æ ¼ï¼Œç»˜åˆ¶ç½‘æ ¼
        if (showGrid) {
            drawGrid(getCurrentGridSize());
        }
        
        // ç»˜åˆ¶å½“å‰å½¢çŠ¶ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        if (currentShape && currentShape.vertices && currentShape.vertices.length > 0) {
            ctx.beginPath();
            ctx.moveTo(currentShape.vertices[0].x, currentShape.vertices[0].y);
            
            for (let i = 1; i < currentShape.vertices.length; i++) {
                ctx.lineTo(currentShape.vertices[i].x, currentShape.vertices[i].y);
            }
            
            ctx.closePath();
            
            // æ ¹æ®é€‰ä¸­çŠ¶æ€è®¾ç½®æ ·å¼
            if (isShapeSelected && selectedShape === 'main') {
                ctx.fillStyle = 'rgba(255, 230, 130, 0.6)';
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 3;
            } else {
                ctx.fillStyle = 'rgba(230, 242, 255, 0.5)';
                ctx.strokeStyle = '#1e5b98';
                ctx.lineWidth = 2;
            }
            
            ctx.fill();
            ctx.stroke();
            
            // ç»˜åˆ¶é¡¶ç‚¹ï¼ˆåœ†å½¢ä¸æ˜¾ç¤ºé¡¶ç‚¹ï¼‰
            if (currentShapeType !== 'circle') {
                if (isShapeSelected && selectedShape === 'main') {
                    ctx.fillStyle = '#ff6b35';
                } else {
                    ctx.fillStyle = '#4c8dbd';
                }
                currentShape.vertices.forEach(vertex => {
                    ctx.beginPath();
                    ctx.arc(vertex.x, vertex.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
        }
        
        // ç»˜åˆ¶è£åˆ‡åçš„æ‰€æœ‰å½¢çŠ¶
        drawAllClippedShapes();
        
        // ç»˜åˆ¶æ‰€æœ‰ç”»ç¬”ç¬”ç”»
        drawAllPenStrokes();
        
        // ç»˜åˆ¶å½“å‰æ­£åœ¨ç»˜åˆ¶çš„ç¬”ç”»
        if (currentStroke && currentStroke.points.length > 0) {
            drawStroke(currentStroke);
        }
        

        
        // ç»˜åˆ¶å‰ªåˆ‡çº¿
        if (cuttingLine && isDrawing && currentTool === 'scissors') {
            ctx.strokeStyle = "red";
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            // æ ¹æ®è£åˆ‡æ¨¡å¼ç»˜åˆ¶çº¿æ¡
            if (cutMode === 'vertical') {
                // å‚ç›´çº¿
                ctx.moveTo(endPoint.x, 0);
                ctx.lineTo(endPoint.x, canvas.height);
            } else if (cutMode === 'horizontal') {
                // æ°´å¹³çº¿
                ctx.moveTo(0, endPoint.y);
                ctx.lineTo(canvas.width, endPoint.y);
            } else {
                // è‡ªç”±çº¿
                ctx.moveTo(startPoint.x, startPoint.y);
                ctx.lineTo(endPoint.x, endPoint.y);
            }
            
            ctx.stroke();
        }
        
        // æ›´æ–°å‰ªåˆ€å·¥å…·çŠ¶æ€ï¼ˆæ ¹æ®å‰ªåˆ‡æ¬¡æ•°ï¼‰
        updateScissorsState();
    }
    
    // ç»˜åˆ¶ç½‘æ ¼
    function drawGrid(gridSize = 80) {
        // å¦‚æœç½‘æ ¼è¢«ç¦ç”¨ï¼Œåˆ™ç›´æ¥è¿”å›
        if (!showGrid) return;
        
        // ç»˜åˆ¶ç½‘æ ¼
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(150, 150, 150, 0.8)';
        ctx.lineWidth = 0.5;
        
        // ç»˜åˆ¶å‚ç›´çº¿
        for (let x = 0; x <= canvas.width; x += gridSize) {
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
        }
        
        // ç»˜åˆ¶æ°´å¹³çº¿
        for (let y = 0; y <= canvas.height; y += gridSize) {
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
        }
        
        ctx.stroke();
    }
    
    // ç»˜åˆ¶å•ä¸ªç¬”ç”»
    function drawStroke(stroke) {
        if (!stroke || !stroke.points || stroke.points.length < 2) return;
        
        ctx.beginPath();
        ctx.strokeStyle = stroke.color;
        ctx.lineWidth = stroke.width;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
        for (let i = 1; i < stroke.points.length; i++) {
            ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
        }
        
        ctx.stroke();
    }
    
    // ç»˜åˆ¶æ‰€æœ‰ç”»ç¬”ç¬”ç”»
    function drawAllPenStrokes() {
        for (const stroke of penStrokes) {
            drawStroke(stroke);
        }
    }
    
    // åˆå§‹åŒ–ç”»å¸ƒ
    function initCanvas() {
        // æ¸…ç©ºç”»å¸ƒ
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // é‡ç½®è£åˆ‡æ•°ç»„
        window.clippedShapes = [];
        
        // é‡ç½®ç”»ç¬”ç¬”ç”»
        penStrokes = [];
        currentStroke = null;
        
        // åˆ›å»ºåˆå§‹å½¢çŠ¶
        const initialShape = createInitialShape();
        
        // è®¾ç½®åˆå§‹å½¢çŠ¶ä¸ºå½“å‰å½¢çŠ¶(ä¿®å¤è£åˆ‡å·¥å…·)
        currentShape = {
            vertices: [...initialShape.vertices],
            edges: []
        };
        
        // åˆ›å»ºè¾¹åˆ—è¡¨
        for (let i = 0; i < initialShape.vertices.length; i++) {
            currentShape.edges.push({
                start: i,
                end: (i + 1) % initialShape.vertices.length
            });
        }
        
        // è®¾ç½®åŸå§‹é¢ç§¯

        
        // é‡ç½®è£åˆ‡æ¬¡æ•°
        cutCount = 0;
        
        // é‡ç½®é€‰ä¸­çŠ¶æ€
        selectedShapeIndex = -1;
        isShapeSelected = false;
        selectedShape = null;
        
        // ä¿å­˜å½“å‰å·¥å…·çŠ¶æ€
        const previousTool = currentTool;
        
        // é‡ç½®å·¥å…·çŠ¶æ€
        setCurrentTool('none');
        
        // å¦‚æœä¹‹å‰æ˜¯å‰ªåˆ€å·¥å…·ï¼Œé‡æ–°æ¿€æ´»å¹¶åº”ç”¨è‡ªåŠ¨é€‰ä¸­é€»è¾‘
        if (previousTool === 'scissors') {
            setCurrentTool('scissors');
        }
        
        // ç»˜åˆ¶å½¢çŠ¶
        drawShape();
        
        // æ˜¾ç¤ºæ¬¢è¿ä¿¡æ¯
        messageEl.textContent = 'è¯·ä½¿ç”¨å‰ªåˆ€å·¥å…·åˆ‡å‰²å›¾å½¢ï¼Œç„¶åæ‹–åŠ¨åˆ‡å‰²åçš„éƒ¨åˆ†è¿›è¡Œæ‹¼æ¥';
        
        // æ¸…ç©ºå†å²è®°å½•å¹¶ä¿å­˜åˆå§‹çŠ¶æ€
        stateHistory = [];
        saveCurrentState();
        updateUndoButton();
    }
    
    // åˆ›å»ºåˆå§‹å½¢çŠ¶
    function createInitialShape() {
        const gridSize = getCurrentGridSize(); // ç½‘æ ¼å¤§å°
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        
        // å°†ä¸­å¿ƒç‚¹å¯¹é½åˆ°ç½‘æ ¼
        const gridCenterX = Math.round(centerX / gridSize) * gridSize;
        const gridCenterY = Math.round(centerY / gridSize) * gridSize;
        
        let vertices = [];
        
        switch(currentShapeType) {
            case 'triangle':
                // åˆ›å»ºä¸‰è§’å½¢ - é¡¶ç‚¹å¯¹é½ç½‘æ ¼
                vertices = [
                    { x: gridCenterX, y: gridCenterY - 240 },     // é¡¶ç‚¹ (3ä¸ªç½‘æ ¼å•ä½)
                    { x: gridCenterX - 320, y: gridCenterY + 160 }, // å·¦ä¸‹ç‚¹ (4ä¸ªç½‘æ ¼å•ä½)
                    { x: gridCenterX + 320, y: gridCenterY + 160 }  // å³ä¸‹ç‚¹ (4ä¸ªç½‘æ ¼å•ä½)
                ];
                break;
                
            case 'trapezoid':
                // åˆ›å»ºæ¢¯å½¢ - é¡¶ç‚¹å¯¹é½ç½‘æ ¼
                vertices = [
                    { x: gridCenterX - 160, y: gridCenterY - 160 }, // å·¦ä¸Šç‚¹ (2ä¸ªç½‘æ ¼å•ä½)
                    { x: gridCenterX + 160, y: gridCenterY - 160 }, // å³ä¸Šç‚¹ (2ä¸ªç½‘æ ¼å•ä½)
                    { x: gridCenterX + 320, y: gridCenterY + 160 }, // å³ä¸‹ç‚¹ (4ä¸ªç½‘æ ¼å•ä½)
                    { x: gridCenterX - 320, y: gridCenterY + 160 }  // å·¦ä¸‹ç‚¹ (4ä¸ªç½‘æ ¼å•ä½)
                ];
                break;
                
            case 'square':
                // åˆ›å»ºæ­£æ–¹å½¢ - é¡¶ç‚¹å¯¹é½ç½‘æ ¼
                vertices = [
                    { x: gridCenterX - 240, y: gridCenterY - 240 }, // å·¦ä¸Šç‚¹ (3ä¸ªç½‘æ ¼å•ä½)
                    { x: gridCenterX + 240, y: gridCenterY - 240 }, // å³ä¸Šç‚¹ (3ä¸ªç½‘æ ¼å•ä½)
                    { x: gridCenterX + 240, y: gridCenterY + 240 }, // å³ä¸‹ç‚¹ (3ä¸ªç½‘æ ¼å•ä½)
                    { x: gridCenterX - 240, y: gridCenterY + 240 }  // å·¦ä¸‹ç‚¹ (3ä¸ªç½‘æ ¼å•ä½)
                ];
                break;
                
            case 'rectangle':
                // åˆ›å»ºé•¿æ–¹å½¢ - é¡¶ç‚¹å¯¹é½ç½‘æ ¼
                vertices = [
                    { x: gridCenterX - 320, y: gridCenterY - 160 }, // å·¦ä¸Šç‚¹ (4x2ä¸ªç½‘æ ¼å•ä½)
                    { x: gridCenterX + 320, y: gridCenterY - 160 }, // å³ä¸Šç‚¹ (4x2ä¸ªç½‘æ ¼å•ä½)
                    { x: gridCenterX + 320, y: gridCenterY + 160 }, // å³ä¸‹ç‚¹ (4x2ä¸ªç½‘æ ¼å•ä½)
                    { x: gridCenterX - 320, y: gridCenterY + 160 }  // å·¦ä¸‹ç‚¹ (4x2ä¸ªç½‘æ ¼å•ä½)
                ];
                break;
                
            case 'circle':
                // åˆ›å»ºåœ†å½¢ - åœ†å¿ƒå¯¹é½ç½‘æ ¼ï¼Œä½†é¡¶ç‚¹ä¸éœ€è¦å¯¹é½
                const radius = 240; // 3ä¸ªç½‘æ ¼å•ä½ä½œä¸ºåŠå¾„
                const segments = 36; // ä½¿ç”¨è¶³å¤Ÿå¤šçš„çº¿æ®µä½¿å…¶çœ‹èµ·æ¥åƒåœ†å½¢
                
                for (let i = 0; i < segments; i++) {
                    const angle = (i / segments) * Math.PI * 2; // è®¡ç®—å½“å‰è§’åº¦
                    const x = gridCenterX + radius * Math.cos(angle);
                    const y = gridCenterY + radius * Math.sin(angle);
                    vertices.push({ x, y });
                }
                break;
                
            case 'custom':
                // è‡ªå®šä¹‰å›¾å½¢ - è¿”å›ç©ºçš„é¡¶ç‚¹æ•°ç»„ï¼Œç”¨æˆ·å¯ä»¥è‡ªå·±ç»˜åˆ¶
                vertices = [];
                break;
                
            case 'parallelogram':
            default:
                // åˆ›å»ºå¹³è¡Œå››è¾¹å½¢ - é¡¶ç‚¹å¯¹é½ç½‘æ ¼
                vertices = [
                    { x: gridCenterX - 160, y: gridCenterY - 80 }, // å·¦ä¸Šç‚¹ (åç§»2ä¸ªç½‘æ ¼å•ä½)
                    { x: gridCenterX + 320, y: gridCenterY - 80 }, // å³ä¸Šç‚¹ (åç§»4ä¸ªç½‘æ ¼å•ä½)
                    { x: gridCenterX + 80, y: gridCenterY + 160 }, // å³ä¸‹ç‚¹ (åç§»2ä¸ªç½‘æ ¼å•ä½)
                    { x: gridCenterX - 400, y: gridCenterY + 160 }  // å·¦ä¸‹ç‚¹ (åç§»4ä¸ªç½‘æ ¼å•ä½)
                ];
                break;
        }
        
        return {
            vertices: vertices,
            color: '#4c8dbd',
            strokeColor: '#1e5b98',
            lineWidth: 2
        };
    }
    
    // å¼€å§‹ç»˜åˆ¶å‰ªåˆ‡çº¿
    function startDrawing(e) {
        isDrawing = true;
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦å¸é™„åˆ°é¡¶ç‚¹
        const snappedPoint = snapToVertex(mouseX, mouseY);
        
        startPoint = snappedPoint || { x: mouseX, y: mouseY };
        
        cuttingLine = {
            start: { ...startPoint },
            end: { ...startPoint }
        };
    }
    
    // å‰ªåˆ‡çº¿ç»˜åˆ¶ä¸­
    function drawing(e) {
        if (!isDrawing) return;
        
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦å¸é™„åˆ°é¡¶ç‚¹
        let snappedPoint = snapToVertex(mouseX, mouseY);
        
        // æ ¹æ®è£åˆ‡æ¨¡å¼é™åˆ¶æ–¹å‘
        if (cutMode === 'vertical') {
            // å‚ç›´è£åˆ‡ï¼šä¿æŒxåæ ‡ä¸èµ·ç‚¹ç›¸åŒï¼Œåªæ”¹å˜yåæ ‡
            endPoint = snappedPoint || { x: startPoint.x, y: mouseY };
        } else if (cutMode === 'horizontal') {
            // æ°´å¹³è£åˆ‡ï¼šä¿æŒyåæ ‡ä¸èµ·ç‚¹ç›¸åŒï¼Œåªæ”¹å˜xåæ ‡
            endPoint = snappedPoint || { x: mouseX, y: startPoint.y };
        } else {
            // è‡ªç”±è£åˆ‡ï¼šæ— é™åˆ¶
            endPoint = snappedPoint || { x: mouseX, y: mouseY };
        }
        
        cuttingLine.end = { ...endPoint };
        drawShape();
    }
    
    // é¡¶ç‚¹å¸é™„åŠŸèƒ½
    function snapToVertex(x, y) {
        if (!currentShape || !currentShape.vertices) return null;
        
        // å¯»æ‰¾è·ç¦»æœ€è¿‘çš„é¡¶ç‚¹
        let closestVertex = null;
        let minDistance = SNAP_DISTANCE;
        
        for (const vertex of currentShape.vertices) {
            const distance = Math.sqrt(
                Math.pow(vertex.x - x, 2) + Math.pow(vertex.y - y, 2)
            );
            
            if (distance < minDistance) {
                minDistance = distance;
                closestVertex = vertex;
            }
        }
        
        return closestVertex ? { ...closestVertex } : null;
    }
    
    // æ£€æŸ¥ç‚¹æ˜¯å¦å¸é™„åˆ°é¡¶ç‚¹
    function isPointSnappedToVertex(point) {
        if (!currentShape || !currentShape.vertices) return false;
        
        for (const vertex of currentShape.vertices) {
            const distance = Math.sqrt(
                Math.pow(vertex.x - point.x, 2) + Math.pow(vertex.y - point.y, 2)
            );
            
            if (distance < 1) {  // å…è®¸æœ‰å¾®å°è¯¯å·®
                return true;
            }
        }
        return false;
    }
    
    // æ˜¾ç¤ºå‰ªåˆ‡å¤±è´¥çš„è§†è§‰åé¦ˆ
    function showCutFailFeedback() {
        // ç»˜åˆ¶çº¢è‰²çš„Xè¡¨ç¤ºå¤±è´¥
        if (cuttingLine) {
            const centerX = (cuttingLine.start.x + cuttingLine.end.x) / 2;
            const centerY = (cuttingLine.start.y + cuttingLine.end.y) / 2;
            
            ctx.save();
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX - 10, centerY - 10);
            ctx.lineTo(centerX + 10, centerY + 10);
            ctx.moveTo(centerX + 10, centerY - 10);
            ctx.lineTo(centerX - 10, centerY + 10);
            ctx.stroke();
            ctx.restore();
            
            // çŸ­æš‚æ˜¾ç¤ºåæ¸…é™¤
            setTimeout(() => {
                drawShape();
            }, 500);
        }
    }
    
    // ç»“æŸç»˜åˆ¶ï¼Œæ‰§è¡Œå‰ªåˆ‡
    function endDrawing() {
        if (!isDrawing) return;
        isDrawing = false;
        
        // æ‰§è¡Œå‰ªåˆ‡æ“ä½œ
        if (cuttingLine) {
            debug("ç»“æŸç»˜åˆ¶ï¼Œå‡†å¤‡æ‰§è¡Œå‰ªåˆ‡æ“ä½œ");
            
            // è®¡ç®—å‰ªåˆ‡çº¿é•¿åº¦
            const dx = cuttingLine.end.x - cuttingLine.start.x;
            const dy = cuttingLine.end.y - cuttingLine.start.y;
            const lineLength = Math.sqrt(dx * dx + dy * dy);
            
            // å¦‚æœå‰ªåˆ‡çº¿å¤ªçŸ­ï¼Œæ ¹æ®æ¨¡å¼è‡ªåŠ¨å»¶é•¿
            const MIN_LENGTH = 10;
            if (lineLength < MIN_LENGTH) {
                debug(`å‰ªåˆ‡çº¿å¤ªçŸ­(${lineLength.toFixed(2)}åƒç´ )ï¼Œè‡ªåŠ¨å»¶é•¿`);
                
                if (cutMode === 'vertical') {
                    // å‚ç›´æ¨¡å¼ä¸‹ï¼Œå»¶é•¿Yæ–¹å‘
                    cuttingLine.end.y = cuttingLine.start.y + (dy >= 0 ? 100 : -100);
                } else if (cutMode === 'horizontal') {
                    // æ°´å¹³æ¨¡å¼ä¸‹ï¼Œå»¶é•¿Xæ–¹å‘
                    cuttingLine.end.x = cuttingLine.start.x + (dx >= 0 ? 100 : -100);
                } else {
                    // è‡ªç”±æ¨¡å¼ä¸‹ï¼ŒæŒ‰åŸæ–¹å‘å»¶é•¿
                    const ratio = 100 / lineLength;
                    cuttingLine.end.x = cuttingLine.start.x + dx * ratio;
                    cuttingLine.end.y = cuttingLine.start.y + dy * ratio;
                }
            }
            
            // æ£€æŸ¥èµ·ç‚¹å’Œç»ˆç‚¹æ˜¯å¦æ˜¯é¡¶ç‚¹
            let startIsVertex = false;
            let endIsVertex = false;
            let startVertexIndex = -1;
            let endVertexIndex = -1;
            
            // æ£€æŸ¥èµ·ç‚¹å’Œç»ˆç‚¹æ˜¯å¦æ˜¯é¡¶ç‚¹
            for (let i = 0; i < currentShape.vertices.length; i++) {
                const vertex = currentShape.vertices[i];
                const distToStart = Math.sqrt(
                    Math.pow(vertex.x - cuttingLine.start.x, 2) + 
                    Math.pow(vertex.y - cuttingLine.start.y, 2)
                );
                
                const distToEnd = Math.sqrt(
                    Math.pow(vertex.x - cuttingLine.end.x, 2) + 
                    Math.pow(vertex.y - cuttingLine.end.y, 2)
                );
                
                if (distToStart < 3) { // å¢åŠ å®¹å·®ï¼Œæé«˜æ£€æµ‹æˆåŠŸç‡
                    startIsVertex = true;
                    startVertexIndex = i;
                }
                
                if (distToEnd < 3) { // å¢åŠ å®¹å·®ï¼Œæé«˜æ£€æµ‹æˆåŠŸç‡
                    endIsVertex = true;
                    endVertexIndex = i;
                }
            }
            
            // å¦‚æœèµ·ç‚¹å’Œç»ˆç‚¹éƒ½æ˜¯é¡¶ç‚¹ï¼Œå¹¶ä¸”ä¸æ˜¯ç›¸åŒçš„é¡¶ç‚¹æˆ–ç›¸é‚»é¡¶ç‚¹ï¼Œé‚£ä¹ˆæ‰§è¡Œè£åˆ‡
            if (startIsVertex && endIsVertex) {
                if (startVertexIndex !== endVertexIndex && 
                   Math.abs(startVertexIndex - endVertexIndex) !== 1 && 
                   !(startVertexIndex === 0 && endVertexIndex === currentShape.vertices.length - 1) && 
                   !(endVertexIndex === 0 && startVertexIndex === currentShape.vertices.length - 1)) {
                    debug("æ£€æµ‹åˆ°ä¸¤ä¸ªéç›¸é‚»é¡¶ç‚¹é—´çš„å‰ªåˆ‡ï¼Œæ‰§è¡Œå‰ªåˆ‡");
                    cut();
                    return;
                } else {
                    debug("æ£€æµ‹åˆ°ç›¸é‚»æˆ–ç›¸åŒé¡¶ç‚¹ï¼Œå¿½ç•¥å‰ªåˆ‡");
                    showCutFailFeedback();
                    return;
                }
            }
            
            // æ£€æŸ¥çº¿æ®µæ˜¯å¦ç©¿è¿‡å½¢çŠ¶
            // å…ˆæ‰¾å‡ºä¸å½¢çŠ¶çš„äº¤ç‚¹
            const intersections = findIntersections();
            
            if (intersections.length >= 2) {
                debug(`æ‰¾åˆ°${intersections.length}ä¸ªäº¤ç‚¹ï¼Œæ‰§è¡Œå‰ªåˆ‡`);
                cut();
            } else {
                debug(`åªæ‰¾åˆ°${intersections.length}ä¸ªäº¤ç‚¹ï¼Œæ— æ³•æ‰§è¡Œå‰ªåˆ‡`);
                // ç»˜åˆ¶ä¸€ä¸ªçº¢è‰²çš„æç¤ºï¼Œè¡¨ç¤ºå‰ªåˆ‡å¤±è´¥
                showCutFailFeedback();
            }
        }
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯æ²¿å¯¹è§’çº¿åˆ‡å‰²
    function isAlongDiagonal(intersections) {
        if (intersections.length < 2) return false;
        
        // è·å–äº¤ç‚¹
        const int1 = intersections[0];
        const int2 = intersections[1];
        
        // æ£€æŸ¥æ˜¯å¦éƒ½æ˜¯é¡¶ç‚¹äº¤ç‚¹
        if (int1.isVertex && int2.isVertex) {
            // å¯¹äºæ­£æ–¹å½¢ï¼Œæ£€æŸ¥ä¸¤ä¸ªé¡¶ç‚¹æ˜¯å¦æ˜¯å¯¹è§’
            if (currentShape.vertices.length === 4) {
                // å¯¹è§’é¡¶ç‚¹ç´¢å¼•å·®æ˜¯2
                const indexDiff = Math.abs(int1.vertexIndex - int2.vertexIndex);
                return indexDiff === 2;
            }
        }
        
        return false;
    }
    
    // æŒ‰ç…§é€†æ—¶é’ˆé¡ºåºæ’åˆ—é¡¶ç‚¹
    function orderVerticesCCW(vertices) {
        // è®¡ç®—è´¨å¿ƒ
        const centroid = calculateCentroid(vertices);
        
        // è®¡ç®—æ¯ä¸ªé¡¶ç‚¹ç›¸å¯¹äºè´¨å¿ƒçš„è§’åº¦
        const verticesWithAngles = vertices.map((vertex, index) => {
            const angle = Math.atan2(vertex.y - centroid.y, vertex.x - centroid.x);
            return { vertex, index, angle };
        });
        
        // æŒ‰è§’åº¦æ’åº
        verticesWithAngles.sort((a, b) => a.angle - b.angle);
        
        // æå–æ’åºåçš„é¡¶ç‚¹
        const orderedVertices = verticesWithAngles.map(item => item.vertex);
        
        // åˆ›å»ºæ–°çš„è¾¹ï¼ˆè¿æ¥ç›¸é‚»é¡¶ç‚¹ï¼‰
        const orderedEdges = [];
        for (let i = 0; i < orderedVertices.length; i++) {
            orderedEdges.push({
                start: i,
                end: (i + 1) % orderedVertices.length
            });
        }
        
        return {
            vertices: orderedVertices,
            edges: orderedEdges
        };
    }
    
    // æ£€æŸ¥æ˜¯å¦å­˜åœ¨äº¤å‰è¿çº¿
    function hasIntersectingEdges(vertices, edges) {
        for (let i = 0; i < edges.length; i++) {
            const edge1 = edges[i];
            const p1 = vertices[edge1.start];
            const p2 = vertices[edge1.end];
            
            for (let j = i + 1; j < edges.length; j++) {
                const edge2 = edges[j];
                const p3 = vertices[edge2.start];
                const p4 = vertices[edge2.end];
                
                // è·³è¿‡å…±äº«é¡¶ç‚¹çš„è¾¹
                if (edge1.start === edge2.start || edge1.start === edge2.end || 
                    edge1.end === edge2.start || edge1.end === edge2.end) {
                    continue;
                }
                
                // æ£€æŸ¥ä¸¤æ¡è¾¹æ˜¯å¦ç›¸äº¤
                const intersection = lineIntersection(p1, p2, p3, p4);
                if (intersection) {
                    return true;
                }
            }
        }
        return false;
    }
    
    // åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨çº¿æ®µä¸Š
    function isPointOnLine(point, lineStart, lineEnd) {
        const d1 = Math.sqrt(
            Math.pow(point.x - lineStart.x, 2) + 
            Math.pow(point.y - lineStart.y, 2)
        );
        
        const d2 = Math.sqrt(
            Math.pow(point.x - lineEnd.x, 2) + 
            Math.pow(point.y - lineEnd.y, 2)
        );
        
        const lineLength = Math.sqrt(
            Math.pow(lineEnd.x - lineStart.x, 2) + 
            Math.pow(lineEnd.y - lineStart.y, 2)
        );
        
        // å…è®¸æœ‰å°è¯¯å·®ï¼ˆ1åƒç´ ï¼‰
        return Math.abs(d1 + d2 - lineLength) < 1;
    }
    
    // è®¡ç®—ä¸¤æ¡çº¿æ®µçš„äº¤ç‚¹ï¼Œä½¿ç”¨æ›´å®½æ¾çš„è¾¹ç•Œæ£€æŸ¥ä»¥æé«˜å¯é æ€§
    function lineIntersection(p1, p2, p3, p4) {
        // çº¿æ®µ1: p1 to p2
        // çº¿æ®µ2: p3 to p4
        
        // æ·»åŠ ä¸€ä¸ªå°çš„è¯¯å·®èŒƒå›´ï¼Œä½¿çº¿æ®µç¨å¾®å»¶é•¿ï¼Œæé«˜äº¤ç‚¹æ£€æµ‹çš„ç¨³å®šæ€§
        const EPSILON = 0.001;
        
        const denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
        
        // å¦‚æœåˆ†æ¯éå¸¸æ¥è¿‘0ï¼Œçº¿æ®µå¹³è¡Œæˆ–å…±çº¿
        if (Math.abs(denominator) < EPSILON) {
            // æ£€æŸ¥å…±çº¿æƒ…å†µ
            // è¿™é‡Œå¯ä»¥æ·»åŠ å…±çº¿æ®µç›¸äº¤çš„æ£€æµ‹ï¼Œä½†æš‚æ—¶ç®€å•è¿”å›null
            return null;
        }
        
        const ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
        const ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;
        
        // ä½¿ç”¨ç¨å¾®å®½æ¾çš„èŒƒå›´æ£€æŸ¥ï¼Œå…è®¸äº¤ç‚¹åœ¨çº¿æ®µç•¥å¾®å»¶é•¿çš„èŒƒå›´å†…
        if (ua >= -EPSILON && ua <= 1 + EPSILON && ub >= -EPSILON && ub <= 1 + EPSILON) {
            // è®¡ç®—å®é™…äº¤ç‚¹ï¼ˆé™åˆ¶åœ¨çº¿æ®µèŒƒå›´å†…ï¼‰
            const uaClipped = Math.max(0, Math.min(1, ua));
            
            return {
                x: p1.x + uaClipped * (p2.x - p1.x),
                y: p1.y + uaClipped * (p2.y - p1.y)
            };
        }
        
        return null;
    }
    
    // å¤„ç†è§¦æ‘¸å¼€å§‹äº‹ä»¶
    function handleTouchStart(e) {
        // é˜»æ­¢å¤šç‚¹è§¦æ§é€ æˆç¼©æ”¾
        if (e.touches.length > 1) {
            e.preventDefault();
            return;
        }
        
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const touchX = touch.clientX - rect.left;
        const touchY = touch.clientY - rect.top;
        
        debug(`è§¦æ‘¸å¼€å§‹: x=${touchX}, y=${touchY}`);
        
        // æ£€æŸ¥æ˜¯å¦åœ¨ç”»å¸ƒåŒºåŸŸå†…
        if (touchX >= 0 && touchX <= rect.width && touchY >= 0 && touchY <= rect.height) {
            e.preventDefault(); // ä»…å½“è§¦æ‘¸åœ¨ç”»å¸ƒåŒºåŸŸå†…æ—¶é˜»æ­¢é»˜è®¤è¡Œä¸º
            
            // å¦‚æœæ­£åœ¨ç»˜åˆ¶è‡ªå®šä¹‰å›¾å½¢
            if (isDrawingCustomShape) {
                handleCustomShapeClick(touchX, touchY);
                return;
            }
            
            // å¦‚æœå‰ªåˆ€å·¥å…·æ¿€æ´»ï¼Œç¦ç”¨å›¾å½¢é€‰ä¸­å’Œæ‹–åŠ¨åŠŸèƒ½
            if (currentTool === 'scissors') {
                // å‰ªåˆ€å·¥å…·çŠ¶æ€ä¸‹ï¼Œåªå¤„ç†åˆ‡å‰²æ“ä½œï¼Œä¸å…è®¸é€‰ä¸­å’Œæ‹–åŠ¨
                if (cutCount < MAX_CUTS) {
                    isDrawing = true;
                    startPoint = { x: touchX, y: touchY };
                    endPoint = { x: touchX, y: touchY };
                    cuttingLine = { start: startPoint, end: endPoint };
                }
                return;
            }
            
            // ä¼˜å…ˆæ£€æŸ¥æ˜¯å¦ç‚¹å‡»åœ¨è£åˆ‡éƒ¨åˆ†ä¸Šï¼ˆæœ€ä¸Šå±‚å›¾å½¢ä¼˜å…ˆï¼‰
            debug(`å¼€å§‹æ£€æŸ¥è£åˆ‡å›¾å½¢...`);
            const clickedShapeIndex = getShapeAtPoint(touchX, touchY);
            
            if (clickedShapeIndex !== -1) {
                // ä¿å­˜å½“å‰çŠ¶æ€ä»¥æ”¯æŒæ’¤é”€
                saveCurrentState();
                
                // é€‰ä¸­å¹¶å¼€å§‹æ‹–åŠ¨è£åˆ‡éƒ¨åˆ†
                selectedShapeIndex = clickedShapeIndex;
                isShapeSelected = false;
                selectedShape = null;
                isDragging = true;
                draggedShapeIndex = clickedShapeIndex;
                dragStartX = touchX;
                dragStartY = touchY;
                canvas.style.cursor = 'move';
                
                debug(`ğŸ¯ æˆåŠŸé€‰ä¸­è£åˆ‡å›¾å½¢ï¼Œç´¢å¼•: ${selectedShapeIndex}`);
                drawShape();
                return;
            } else {
                // å¦‚æœæ²¡æœ‰ç‚¹å‡»åœ¨è£åˆ‡å›¾å½¢ä¸Šï¼Œæ£€æŸ¥æ˜¯å¦ç‚¹å‡»åœ¨ä¸»å›¾å½¢ä¸Š
                debug(`æ£€æŸ¥ä¸»å›¾å½¢: currentShapeå­˜åœ¨=${!!currentShape}, æœ‰é¡¶ç‚¹=${!!(currentShape && currentShape.vertices)}`);
                if (currentShape && currentShape.vertices && isPointInShape(touchX, touchY, currentShape)) {
                    // ä¿å­˜å½“å‰çŠ¶æ€ä»¥æ”¯æŒæ’¤é”€
                    saveCurrentState();
                    
                    // é€‰ä¸­ä¸»å›¾å½¢
                    isShapeSelected = true;
                    selectedShape = 'main';
                    selectedShapeIndex = -1; // å–æ¶ˆè£åˆ‡éƒ¨åˆ†çš„é€‰ä¸­
                    isDragging = true;
                    dragStartX = touchX;
                    dragStartY = touchY;
                    canvas.style.cursor = 'move';
                    debug(`ğŸ”µ é€‰ä¸­ä¸»å›¾å½¢`);
                    drawShape();
                    return;
                } else {
                    // ç‚¹å‡»ç©ºç™½å¤„ï¼Œå–æ¶ˆæ‰€æœ‰é€‰ä¸­
                    selectedShapeIndex = -1;
                    isShapeSelected = false;
                    selectedShape = null;
                    debug(`ç‚¹å‡»ç©ºç™½å¤„ï¼Œå–æ¶ˆæ‰€æœ‰é€‰ä¸­`);
                    drawShape();
                }
            }
            
            // æ ¹æ®å½“å‰å·¥å…·æ‰§è¡Œç›¸åº”æ“ä½œ
            if (currentTool === 'scissors' && cutCount < MAX_CUTS) {
                isDrawing = true;
                const snappedPoint = snapToVertex(touchX, touchY);
                startPoint = snappedPoint || { x: touchX, y: touchY };
                cuttingLine = {
                    start: { ...startPoint },
                    end: { ...startPoint }
                };
            } else if (currentTool === 'pen') {
                isPenDrawing = true;
                ctx.beginPath();
                ctx.moveTo(touchX, touchY);
                ctx.strokeStyle = penColor;
                ctx.lineWidth = penWidth;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
            }
        }
    }
    
    // å¤„ç†è§¦æ‘¸ç§»åŠ¨äº‹ä»¶
    function handleTouchMove(e) {
        // åªåœ¨ç»˜åˆ¶æˆ–æ‹–åŠ¨è¿‡ç¨‹ä¸­é˜»æ­¢é»˜è®¤è¡Œä¸º
        if ((currentTool === 'scissors' && isDrawing) || 
            (currentTool === 'pen' && isPenDrawing) ||
            isDragging) {
            e.preventDefault();
            
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;
            
            // æ‹–åŠ¨ä¸»å›¾å½¢
            if (isDragging && isShapeSelected && selectedShape === 'main') {
                const dx = touchX - dragStartX;
                const dy = touchY - dragStartY;
                
                // ç§»åŠ¨ä¸»å›¾å½¢çš„æ‰€æœ‰é¡¶ç‚¹
                if (currentShape && currentShape.vertices) {
                    for (let i = 0; i < currentShape.vertices.length; i++) {
                        currentShape.vertices[i].x += dx;
                        currentShape.vertices[i].y += dy;
                    }
                }
                
                dragStartX = touchX;
                dragStartY = touchY;
                
                drawShape();
                return;
            }
            
            // æ‹–åŠ¨è£åˆ‡éƒ¨åˆ†
            if (isDragging && draggedShapeIndex !== -1) {
                const dx = touchX - dragStartX;
                const dy = touchY - dragStartY;
                
                // ç§»åŠ¨è¢«æ‹–åŠ¨çš„å½¢çŠ¶çš„æ‰€æœ‰é¡¶ç‚¹
                const shape = window.clippedShapes[draggedShapeIndex];
                for (let i = 0; i < shape.vertices.length; i++) {
                    shape.vertices[i].x += dx;
                    shape.vertices[i].y += dy;
                }
                
                dragStartX = touchX;
                dragStartY = touchY;
                
                drawShape();
                return;
            }
            
            if (currentTool === 'scissors' && isDrawing && cutCount < MAX_CUTS) {
                // æ£€æŸ¥æ˜¯å¦éœ€è¦å¸é™„åˆ°é¡¶ç‚¹
                let snappedPoint = snapToVertex(touchX, touchY);
                
                // æ ¹æ®è£åˆ‡æ¨¡å¼é™åˆ¶æ–¹å‘
                if (cutMode === 'vertical') {
                    // å‚ç›´è£åˆ‡ï¼šä¿æŒxåæ ‡ä¸èµ·ç‚¹ç›¸åŒï¼Œåªæ”¹å˜yåæ ‡
                    endPoint = snappedPoint || { x: startPoint.x, y: touchY };
                } else if (cutMode === 'horizontal') {
                    // æ°´å¹³è£åˆ‡ï¼šä¿æŒyåæ ‡ä¸èµ·ç‚¹ç›¸åŒï¼Œåªæ”¹å˜xåæ ‡
                    endPoint = snappedPoint || { x: touchX, y: startPoint.y };
                } else {
                    // è‡ªç”±è£åˆ‡ï¼šæ— é™åˆ¶
                    endPoint = snappedPoint || { x: touchX, y: touchY };
                }
                
                cuttingLine.end = { ...endPoint };
                drawShape();
            } else if (currentTool === 'pen' && isPenDrawing) {
                ctx.lineTo(touchX, touchY);
                ctx.stroke();
            }
        }
    }
    
    // å¤„ç†è§¦æ‘¸ç»“æŸäº‹ä»¶
    function handleTouchEnd(e) {
        // åªåœ¨ç»˜åˆ¶æˆ–æ‹–åŠ¨è¿‡ç¨‹ä¸­é˜»æ­¢é»˜è®¤è¡Œä¸º
        if ((currentTool === 'scissors' && isDrawing) || 
            (currentTool === 'pen' && isPenDrawing) ||
            isDragging) {
            e.preventDefault();
            
            if (isDragging) {
                isDragging = false;
                draggedShapeIndex = -1;
                canvas.style.cursor = 'default';
                
                if (isShapeSelected && selectedShape === 'main') {
                    debug(`ä¸»å›¾å½¢æ‹–åŠ¨ç»“æŸï¼Œä¿æŒé€‰ä¸­çŠ¶æ€`);
                } else {
                    debug(`è§¦æ‘¸æ‹–åŠ¨ç»“æŸï¼Œä¿æŒé€‰ä¸­: ${selectedShapeIndex}`);
                }
                return;
            }
            
            if (currentTool === 'scissors' && isDrawing && cutCount < MAX_CUTS) {
                isDrawing = false;
                
                // æ‰§è¡Œå‰ªåˆ‡æ“ä½œ
                if (cuttingLine) {
                    // åœ¨æ°´å¹³å’Œå‚ç›´æ¨¡å¼ä¸‹ï¼Œå¦‚æœèµ·ç‚¹å’Œç»ˆç‚¹è·ç¦»è¿‡è¿‘ï¼Œåˆ™å¢åŠ æœ€å°è·ç¦»
                    if (cutMode === 'vertical' || cutMode === 'horizontal') {
                        const dx = cuttingLine.end.x - cuttingLine.start.x;
                        const dy = cuttingLine.end.y - cuttingLine.start.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // å¦‚æœè·ç¦»å¤ªå°ï¼Œè°ƒæ•´ç»ˆç‚¹ä½ç½®
                        if (distance < 10) {
                            if (cutMode === 'vertical') {
                                // å‚ç›´æ¨¡å¼ä¸‹ï¼Œå¢åŠ /å‡å°‘yå€¼
                                cuttingLine.end.y = cuttingLine.start.y + (dy >= 0 ? 20 : -20);
                            } else {
                                // æ°´å¹³æ¨¡å¼ä¸‹ï¼Œå¢åŠ /å‡å°‘xå€¼
                                cuttingLine.end.x = cuttingLine.start.x + (dx >= 0 ? 20 : -20);
                            }
                        }
                    }
                    
                    // æ£€æŸ¥çº¿æ®µæ˜¯å¦æœ‰è¶³å¤Ÿé•¿åº¦ï¼Œæˆ–æ˜¯æ°´å¹³/å‚ç›´æ¨¡å¼
                    const isValidCut = cutMode === 'vertical' || cutMode === 'horizontal' || 
                                       (cuttingLine.start.x !== cuttingLine.end.x && cuttingLine.start.y !== cuttingLine.end.y);
                    
                    if (isValidCut) {
                        cut();
                    }
                }
            } else if (currentTool === 'pen' && isPenDrawing) {
                isPenDrawing = false;
            }
        }
    }
    
    // å¤„ç†é‡ç½®æŒ‰é’®ç‚¹å‡»
    function handleReset() {
        debug('é‡ç½®æ“ä½œ');
        
        // æ ¹æ®å½“å‰çŠ¶æ€æ™ºèƒ½é‡ç½®
        if (isDrawingCustomShape) {
            // è‡ªå®šä¹‰ç»˜å›¾çŠ¶æ€ï¼šæ¸…é™¤è‡ªå®šä¹‰ç»˜å›¾å¹¶ä¿æŒç»˜åˆ¶çŠ¶æ€æ¿€æ´»
            customShapeVertices = [];
            tempCustomVertex = null;
            
            // ä¿æŒç»˜åˆ¶çŠ¶æ€å’ŒæŒ‰é’®æ˜¾ç¤º
            // isDrawingCustomShape ä¿æŒä¸º true
            // finishDrawingBtn ä¿æŒæ˜¾ç¤º
            
            // é‡æ–°ç»˜åˆ¶é¢„è§ˆ
            drawCustomShapePreview();
            
            messageEl.textContent = 'å·²æ¸…é™¤å½“å‰è‡ªå®šä¹‰å›¾å½¢ï¼Œå¯ä»¥é‡æ–°å¼€å§‹ç»˜åˆ¶';
            setTimeout(() => {
                if (messageEl.textContent === 'å·²æ¸…é™¤å½“å‰è‡ªå®šä¹‰å›¾å½¢ï¼Œå¯ä»¥é‡æ–°å¼€å§‹ç»˜åˆ¶') {
                    messageEl.textContent = '';
                }
            }, 2000);
        } else if (currentTool === 'pen' && penStrokes.length > 0) {
            // ç”»ç¬”çŠ¶æ€ï¼šåªæ¸…é™¤ç”»ç¬”ç¬”ç”»ï¼Œä½†ä¿æŒå›¾å½¢çš„å…¶ä»–çŠ¶æ€
            penStrokes = [];
            currentStroke = null;
            isPenDrawing = false;
            drawShape();
            messageEl.textContent = 'å·²æ¸…é™¤æ‰€æœ‰ç”»ç¬”ç¬”ç”»';
            setTimeout(() => {
                if (messageEl.textContent === 'å·²æ¸…é™¤æ‰€æœ‰ç”»ç¬”ç¬”ç”»') {
                    messageEl.textContent = '';
                }
            }, 2000);
        } else {
            // æ‰€æœ‰å…¶ä»–æƒ…å†µï¼šå®Œå…¨é‡ç½®åˆ°åˆå§‹çŠ¶æ€
            // åŒ…æ‹¬è£åˆ‡åã€æ‹–åŠ¨åã€æ—‹è½¬åç­‰æ‰€æœ‰çŠ¶æ€
            
            // æ£€æŸ¥å½“å‰å›¾å½¢é€‰æ‹©
            if (currentShapeType === 'custom') {
                // å¦‚æœå½“å‰é€‰æ‹©çš„æ˜¯è‡ªå®šä¹‰å›¾å½¢ï¼Œæ¿€æ´»è‡ªå®šä¹‰å›¾å½¢ç¼–è¾‘çŠ¶æ€
                startCustomShapeDrawing();
            } else {
                // å®Œå…¨é‡ç½®åˆ°åˆå§‹çŠ¶æ€
                initCanvas();
            }
            
            messageEl.textContent = 'å·²é‡ç½®åˆ°åˆå§‹çŠ¶æ€';
            setTimeout(() => {
                if (messageEl.textContent === 'å·²é‡ç½®åˆ°åˆå§‹çŠ¶æ€') {
                    messageEl.textContent = '';
                }
            }, 2000);
        }
    }
    
    // è®¡ç®—ç‚¹åˆ°çº¿æ®µçš„è·ç¦»
    function distancePointToLine(point, lineStart, lineEnd) {
        const A = point.x - lineStart.x;
        const B = point.y - lineStart.y;
        const C = lineEnd.x - lineStart.x;
        const D = lineEnd.y - lineStart.y;
        
        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;
        
        if (lenSq !== 0) {
            param = dot / lenSq;
        }
        
        let xx, yy;
        
        if (param < 0) {
            xx = lineStart.x;
            yy = lineStart.y;
        } else if (param > 1) {
            xx = lineEnd.x;
            yy = lineEnd.y;
        } else {
            xx = lineStart.x + param * C;
            yy = lineStart.y + param * D;
        }
        
        const dx = point.x - xx;
        const dy = point.y - yy;
        
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    // æ—‹è½¬è£åˆ‡éƒ¨åˆ†
    function rotateClippedShape() {
        debug(`å¼€å§‹æ—‹è½¬, é€‰ä¸­ä¸»å›¾å½¢: ${isShapeSelected}, é€‰ä¸­è£åˆ‡å›¾å½¢: ${selectedShapeIndex}`);
        
        // è·å–æ»‘å—çš„è§’åº¦å€¼
        const rotationSlider = document.getElementById('rotationSlider');
        const angle = rotationSlider ? parseFloat(rotationSlider.value) : 45;
        
        // å¦‚æœé€‰ä¸­çš„æ˜¯ä¸»å›¾å½¢
        if (isShapeSelected && selectedShape === 'main' && currentShape) {
            debug(`æ—‹è½¬ä¸»å›¾å½¢ï¼Œè§’åº¦: ${angle}Â°`);
            
            // æ—‹è½¬è§’åº¦ï¼ˆå¼§åº¦ï¼‰
            const angleInRadians = angle * Math.PI / 180;
            
            // è®¡ç®—å½¢çŠ¶çš„è´¨å¿ƒï¼ˆæ—‹è½¬ä¸­å¿ƒï¼‰
            const centroid = calculateCentroid(currentShape.vertices || currentShape);
            
            // æ—‹è½¬æ¯ä¸ªé¡¶ç‚¹
            const vertices = currentShape.vertices || currentShape;
            for (let i = 0; i < vertices.length; i++) {
                const vertex = vertices[i];
                
                // é¡¶ç‚¹ç›¸å¯¹äºè´¨å¿ƒçš„åæ ‡
                const x = vertex.x - centroid.x;
                const y = vertex.y - centroid.y;
                
                // åº”ç”¨æ—‹è½¬å˜æ¢
                const rotatedX = x * Math.cos(angleInRadians) - y * Math.sin(angleInRadians);
                const rotatedY = x * Math.sin(angleInRadians) + y * Math.cos(angleInRadians);
                
                // æ›´æ–°é¡¶ç‚¹åæ ‡
                vertex.x = rotatedX + centroid.x;
                vertex.y = rotatedY + centroid.y;
            }
            
            drawShape();
            return;
        }
        
        // å¦‚æœæ²¡æœ‰è£åˆ‡éƒ¨åˆ†ï¼Œç›´æ¥è¿”å›
        if (!window.clippedShapes || window.clippedShapes.length === 0) {
            debug(`æ²¡æœ‰è£åˆ‡éƒ¨åˆ†ï¼Œæ— æ³•æ—‹è½¬`);
            return;
        }
        
        // å¦‚æœæ²¡æœ‰é€‰ä¸­çš„å›¾å½¢ï¼Œæ˜¾ç¤ºæç¤ºæ¶ˆæ¯
        if (selectedShapeIndex === -1) {
            debug(`æœªé€‰ä¸­å›¾å½¢ï¼Œæ˜¾ç¤ºæç¤º`);
            messageEl.textContent = 'è¯·å…ˆç‚¹å‡»é€‰æ‹©è¦æ—‹è½¬çš„å›¾å½¢';
            setTimeout(() => {
                if (messageEl.textContent === 'è¯·å…ˆç‚¹å‡»é€‰æ‹©è¦æ—‹è½¬çš„å›¾å½¢') {
                    messageEl.textContent = '';
                }
            }, 3000);
            return;
        }
        
        // ç¡®ä¿é€‰ä¸­çš„ç´¢å¼•æœ‰æ•ˆ
        if (selectedShapeIndex >= 0 && selectedShapeIndex < window.clippedShapes.length) {
            debug(`æ—‹è½¬å›¾å½¢: ${selectedShapeIndex}ï¼Œè§’åº¦: ${angle}Â°`);
            // è·å–é€‰ä¸­çš„å›¾å½¢
            const shape = window.clippedShapes[selectedShapeIndex];
            
            // æ—‹è½¬è§’åº¦ï¼ˆå¼§åº¦ï¼‰
            const angleInRadians = angle * Math.PI / 180;
            
            // è®¡ç®—å½¢çŠ¶çš„è´¨å¿ƒï¼ˆæ—‹è½¬ä¸­å¿ƒï¼‰
            const centroid = calculateCentroid(shape.vertices);
            
            // æ—‹è½¬æ¯ä¸ªé¡¶ç‚¹
            for (let i = 0; i < shape.vertices.length; i++) {
                const vertex = shape.vertices[i];
                
                // é¡¶ç‚¹ç›¸å¯¹äºè´¨å¿ƒçš„åæ ‡
                const x = vertex.x - centroid.x;
                const y = vertex.y - centroid.y;
                
                // åº”ç”¨æ—‹è½¬å˜æ¢
                const rotatedX = x * Math.cos(angleInRadians) - y * Math.sin(angleInRadians);
                const rotatedY = x * Math.sin(angleInRadians) + y * Math.cos(angleInRadians);
                
                // æ›´æ–°é¡¶ç‚¹åæ ‡
                vertex.x = centroid.x + rotatedX;
                vertex.y = centroid.y + rotatedY;
            }
            
            // é‡æ–°ç»˜åˆ¶
            drawShape();
            

            
            // æ£€æŸ¥å½¢çŠ¶æ˜¯å¦æ¥è¿‘é•¿æ–¹å½¢
            checkRectangularShape();
        } else {
            debug(`é€‰ä¸­çš„å›¾å½¢ç´¢å¼•è¶…å‡ºèŒƒå›´: ${selectedShapeIndex}`);
        }
    }
    
    // æ°´å¹³ç¿»è½¬å›¾å½¢
    function flipHorizontalShape() {
        debug(`å¼€å§‹æ°´å¹³ç¿»è½¬, é€‰ä¸­ä¸»å›¾å½¢: ${isShapeSelected}, é€‰ä¸­è£åˆ‡å›¾å½¢: ${selectedShapeIndex}`);
        
        // å¦‚æœé€‰ä¸­çš„æ˜¯ä¸»å›¾å½¢
        if (isShapeSelected && selectedShape === 'main' && currentShape) {
            debug(`æ°´å¹³ç¿»è½¬ä¸»å›¾å½¢`);
            
            // è®¡ç®—å½¢çŠ¶çš„è´¨å¿ƒï¼ˆç¿»è½¬ä¸­å¿ƒï¼‰
            const centroid = calculateCentroid(currentShape.vertices || currentShape);
            
            // æ°´å¹³ç¿»è½¬æ¯ä¸ªé¡¶ç‚¹
            const vertices = currentShape.vertices || currentShape;
            for (let i = 0; i < vertices.length; i++) {
                const vertex = vertices[i];
                
                // é¡¶ç‚¹ç›¸å¯¹äºè´¨å¿ƒçš„xåæ ‡
                const relativeX = vertex.x - centroid.x;
                
                // æ°´å¹³ç¿»è½¬ï¼Œxåæ ‡å–å
                vertex.x = centroid.x - relativeX;
            }
            
            drawShape();
            return;
        }
        
        // å¦‚æœæ²¡æœ‰è£åˆ‡éƒ¨åˆ†ï¼Œç›´æ¥è¿”å›
        if (!window.clippedShapes || window.clippedShapes.length === 0) {
            debug(`æ²¡æœ‰è£åˆ‡éƒ¨åˆ†ï¼Œæ— æ³•ç¿»è½¬`);
            return;
        }
        
        // å¦‚æœæ²¡æœ‰é€‰ä¸­çš„å›¾å½¢ï¼Œæ˜¾ç¤ºæç¤ºæ¶ˆæ¯
        if (selectedShapeIndex === -1) {
            debug(`æœªé€‰ä¸­å›¾å½¢ï¼Œæ˜¾ç¤ºæç¤º`);
            messageEl.textContent = 'è¯·å…ˆç‚¹å‡»é€‰æ‹©è¦ç¿»è½¬çš„å›¾å½¢';
            setTimeout(() => {
                if (messageEl.textContent === 'è¯·å…ˆç‚¹å‡»é€‰æ‹©è¦ç¿»è½¬çš„å›¾å½¢') {
                    messageEl.textContent = '';
                }
            }, 3000);
            return;
        }
        
        // ç¡®ä¿é€‰ä¸­çš„ç´¢å¼•æœ‰æ•ˆ
        if (selectedShapeIndex >= 0 && selectedShapeIndex < window.clippedShapes.length) {
            debug(`æ°´å¹³ç¿»è½¬å›¾å½¢: ${selectedShapeIndex}`);
            // è·å–é€‰ä¸­çš„å›¾å½¢
            const shape = window.clippedShapes[selectedShapeIndex];
            
            // è®¡ç®—å½¢çŠ¶çš„è´¨å¿ƒï¼ˆç¿»è½¬ä¸­å¿ƒï¼‰
            const centroid = calculateCentroid(shape.vertices);
            
            // æ°´å¹³ç¿»è½¬æ¯ä¸ªé¡¶ç‚¹
            for (let i = 0; i < shape.vertices.length; i++) {
                const vertex = shape.vertices[i];
                
                // é¡¶ç‚¹ç›¸å¯¹äºè´¨å¿ƒçš„xåæ ‡
                const relativeX = vertex.x - centroid.x;
                
                // æ°´å¹³ç¿»è½¬ï¼Œxåæ ‡å–å
                vertex.x = centroid.x - relativeX;
            }
            
            // é‡æ–°ç»˜åˆ¶
            drawShape();
            

            
            // æ£€æŸ¥å½¢çŠ¶æ˜¯å¦æ¥è¿‘é•¿æ–¹å½¢
            checkRectangularShape();
            
            // æ˜¾ç¤ºç¿»è½¬å®Œæˆæç¤º
            messageEl.textContent = 'å›¾å½¢å·²æ°´å¹³ç¿»è½¬';
            setTimeout(() => {
                if (messageEl.textContent === 'å›¾å½¢å·²æ°´å¹³ç¿»è½¬') {
                    messageEl.textContent = '';
                }
            }, 1500);
        } else {
            debug(`é€‰ä¸­çš„å›¾å½¢ç´¢å¼•è¶…å‡ºèŒƒå›´: ${selectedShapeIndex}`);
        }
    }
    
    // è®¾ç½®ä¸»ä½“å›¾å½¢å‡½æ•°
    function setMainShape() {
        debug(`å¼€å§‹è®¾ç½®ä¸»ä½“, é€‰ä¸­å›¾å½¢: ${selectedShapeIndex}`);
        
        // æ£€æŸ¥æ˜¯å¦æœ‰è£å‰ªçš„å›¾å½¢æˆ–å½“å‰ä¸»ä½“å›¾å½¢
        if ((!window.clippedShapes || window.clippedShapes.length === 0) && !currentShape) {
            messageEl.textContent = 'æ²¡æœ‰å¯è®¾ç½®çš„å›¾å½¢ï¼Œè¯·å…ˆåˆ›å»ºæˆ–è£åˆ‡å›¾å½¢ï¼';
            setTimeout(() => {
                if (messageEl.textContent === 'æ²¡æœ‰å¯è®¾ç½®çš„å›¾å½¢ï¼Œè¯·å…ˆåˆ›å»ºæˆ–è£åˆ‡å›¾å½¢ï¼') {
                    messageEl.textContent = '';
                }
            }, 2000);
            return;
        }
        
        // æ£€æŸ¥æ˜¯å¦é€‰ä¸­äº†å›¾å½¢
        if (selectedShapeIndex === -1) {
            messageEl.textContent = 'è¯·å…ˆé€‰ä¸­ä¸€ä¸ªå›¾å½¢ä½œä¸ºä¸»ä½“ï¼';
            setTimeout(() => {
                if (messageEl.textContent === 'è¯·å…ˆé€‰ä¸­ä¸€ä¸ªå›¾å½¢ä½œä¸ºä¸»ä½“ï¼') {
                    messageEl.textContent = '';
                }
            }, 2000);
            return;
        }
        
        // æ£€æŸ¥é€‰ä¸­çš„å›¾å½¢ç´¢å¼•æ˜¯å¦æœ‰æ•ˆ
        if (selectedShapeIndex >= 0 && selectedShapeIndex < window.clippedShapes.length) {
            debug(`è®¾ç½®å›¾å½¢ ${selectedShapeIndex} ä¸ºä¸»ä½“`);
            
            // åœ¨æ‰§è¡Œè®¾ç½®ä¸»ä½“å‰ä¿å­˜å½“å‰çŠ¶æ€
            saveCurrentState();
            
            // å¦‚æœå½“å‰å·²æœ‰ä¸»ä½“å›¾å½¢ï¼Œå°†å…¶æ·»åŠ åˆ°è£å‰ªå›¾å½¢æ•°ç»„ä¸­
            if (currentShape && currentShape.vertices && currentShape.vertices.length > 0) {
                window.clippedShapes.push({
                    vertices: [...currentShape.vertices],
                    color: currentShape.color,
                    strokeColor: currentShape.strokeColor,
                    lineWidth: currentShape.lineWidth
                });
                debug(`å°†åŸä¸»ä½“å›¾å½¢æ·»åŠ åˆ°è£å‰ªæ•°ç»„ä¸­`);
            }
            
            // å°†é€‰ä¸­çš„å›¾å½¢è®¾ç½®ä¸ºå½“å‰ä¸»ä½“å›¾å½¢
            const selectedClippedShape = window.clippedShapes[selectedShapeIndex];
            currentShape = {
                vertices: [...selectedClippedShape.vertices], // å¤åˆ¶é¡¶ç‚¹æ•°ç»„
                color: selectedClippedShape.color,
                strokeColor: selectedClippedShape.strokeColor,
                lineWidth: selectedClippedShape.lineWidth,
                edges: [] // åˆå§‹åŒ–è¾¹æ•°ç»„
            };
            
            // é‡æ–°ç”Ÿæˆè¾¹åˆ—è¡¨ï¼Œç¡®ä¿å¯ä»¥è¿›è¡Œåˆ‡å‰²æ“ä½œ
            for (let i = 0; i < currentShape.vertices.length; i++) {
                currentShape.edges.push({
                    start: i,
                    end: (i + 1) % currentShape.vertices.length
                });
            }
            debug(`ä¸ºæ–°ä¸»ä½“å›¾å½¢ç”Ÿæˆäº† ${currentShape.edges.length} æ¡è¾¹`);
            
            // ä»è£å‰ªå›¾å½¢æ•°ç»„ä¸­ç§»é™¤è¯¥å›¾å½¢
            window.clippedShapes.splice(selectedShapeIndex, 1);
            
            // è®¾ç½®ä¸»ä½“å›¾å½¢ä¸ºé€‰ä¸­çŠ¶æ€
            selectedShape = 'main';
            selectedShapeIndex = -1;
            isShapeSelected = true;
            
            // é‡æ–°ç»˜åˆ¶
            drawShape();
            

            
            // æ˜¾ç¤ºè®¾ç½®å®Œæˆæç¤º
            messageEl.textContent = 'ä¸»ä½“å›¾å½¢å·²è®¾ç½®ï¼Œå…¶ä»–å›¾å½¢ä¿ç•™ï¼Œç°åœ¨å¯ä»¥å¯¹æ–°ä¸»ä½“è¿›è¡Œåˆ‡å‰²æ“ä½œï¼';
            setTimeout(() => {
                if (messageEl.textContent === 'ä¸»ä½“å›¾å½¢å·²è®¾ç½®ï¼Œå…¶ä»–å›¾å½¢ä¿ç•™ï¼Œç°åœ¨å¯ä»¥å¯¹æ–°ä¸»ä½“è¿›è¡Œåˆ‡å‰²æ“ä½œï¼') {
                    messageEl.textContent = '';
                }
            }, 3000);
            
            // æ›´æ–°æ’¤é”€æŒ‰é’®çŠ¶æ€
            updateUndoButton();
        } else {
             debug(`é€‰ä¸­çš„å›¾å½¢ç´¢å¼•è¶…å‡ºèŒƒå›´: ${selectedShapeIndex}`);
         }
     }
     
     // ä¿å­˜å½“å‰çŠ¶æ€åˆ°å†å²è®°å½•
     function saveCurrentState() {
         const state = {
             currentShape: currentShape ? {
                 vertices: [...currentShape.vertices],
                 color: currentShape.color,
                 strokeColor: currentShape.strokeColor,
                 lineWidth: currentShape.lineWidth,
                 edges: [...currentShape.edges]
             } : null,
             clippedShapes: window.clippedShapes ? window.clippedShapes.map(shape => ({
                 vertices: [...shape.vertices],
                 color: shape.color,
                 strokeColor: shape.strokeColor,
                 lineWidth: shape.lineWidth
             })) : [],
             cutCount: cutCount,
             selectedShapeIndex: selectedShapeIndex
         };
         
         // æ·»åŠ åˆ°å†å²è®°å½•
         stateHistory.push(state);
         
         // é™åˆ¶å†å²è®°å½•æ•°é‡
         if (stateHistory.length > MAX_HISTORY) {
             stateHistory.shift(); // ç§»é™¤æœ€æ—§çš„è®°å½•
         }
         
         debug(`ä¿å­˜çŠ¶æ€ï¼Œå½“å‰å†å²è®°å½•æ•°é‡: ${stateHistory.length}`);
     }
     
     // æ’¤é”€ä¸Šä¸€æ­¥æ“ä½œ
     function undoLastAction() {
         // æ ¹æ®å½“å‰çŠ¶æ€æ‰§è¡Œä¸åŒçš„æ’¤é”€æ“ä½œ
         if (isDrawingCustomShape && customShapeVertices.length > 0) {
             // è‡ªå®šä¹‰ç»˜å›¾çŠ¶æ€ï¼šæ’¤é”€æœ€åä¸€ä¸ªé¡¶ç‚¹
             customShapeVertices.pop();
             drawCustomShapePreview();
             messageEl.textContent = `å·²æ’¤é”€æœ€åä¸€ä¸ªé¡¶ç‚¹ï¼Œå½“å‰é¡¶ç‚¹æ•°ï¼š${customShapeVertices.length}`;
             setTimeout(() => {
                 if (messageEl.textContent.includes('å·²æ’¤é”€æœ€åä¸€ä¸ªé¡¶ç‚¹')) {
                     messageEl.textContent = '';
                 }
             }, 2000);
             return;
         } else if (currentTool === 'pen' && penStrokes.length > 0) {
             // ç”»ç¬”çŠ¶æ€ï¼šæ’¤é”€æœ€åä¸€ä¸ªç¬”ç”»
             penStrokes.pop();
             drawShape();
             messageEl.textContent = `å·²æ’¤é”€æœ€åä¸€ä¸ªç¬”ç”»ï¼Œå‰©ä½™ç¬”ç”»æ•°ï¼š${penStrokes.length}`;
             setTimeout(() => {
                 if (messageEl.textContent.includes('å·²æ’¤é”€æœ€åä¸€ä¸ªç¬”ç”»')) {
                     messageEl.textContent = '';
                 }
             }, 2000);
             return;
         }
         
         // é»˜è®¤æ’¤é”€ï¼šä½¿ç”¨çŠ¶æ€å†å²
         if (stateHistory.length === 0) {
             messageEl.textContent = 'æ²¡æœ‰å¯æ’¤é”€çš„æ“ä½œï¼';
             setTimeout(() => {
                 if (messageEl.textContent === 'æ²¡æœ‰å¯æ’¤é”€çš„æ“ä½œï¼') {
                     messageEl.textContent = '';
                 }
             }, 2000);
             return;
         }
         
         // è·å–ä¸Šä¸€ä¸ªçŠ¶æ€
         const previousState = stateHistory.pop();
         
         // æ¢å¤çŠ¶æ€
         currentShape = previousState.currentShape ? {
             vertices: [...previousState.currentShape.vertices],
             color: previousState.currentShape.color,
             strokeColor: previousState.currentShape.strokeColor,
             lineWidth: previousState.currentShape.lineWidth,
             edges: [...previousState.currentShape.edges]
         } : null;
         
         window.clippedShapes = previousState.clippedShapes.map(shape => ({
             vertices: [...shape.vertices],
             color: shape.color,
             strokeColor: shape.strokeColor,
             lineWidth: shape.lineWidth
         }));
         
         cutCount = previousState.cutCount;
         selectedShapeIndex = previousState.selectedShapeIndex;
         
         // é‡æ–°ç»˜åˆ¶
         drawShape();
         
         // æ›´æ–°å‰ªåˆ€å·¥å…·çŠ¶æ€
         updateScissorsState();
         
         // æ›´æ–°æ’¤é”€æŒ‰é’®çŠ¶æ€
         updateUndoButton();
         
         // æ˜¾ç¤ºæ’¤é”€å®Œæˆæç¤º
         messageEl.textContent = 'å·²æ’¤é”€ä¸Šä¸€æ­¥æ“ä½œï¼';
         setTimeout(() => {
             if (messageEl.textContent === 'å·²æ’¤é”€ä¸Šä¸€æ­¥æ“ä½œï¼') {
                 messageEl.textContent = '';
             }
         }, 2000);
         
         debug(`æ’¤é”€æ“ä½œå®Œæˆï¼Œå‰©ä½™å†å²è®°å½•æ•°é‡: ${stateHistory.length}`);
     }
     
     // è‡ªå®šä¹‰å›¾å½¢ç»˜åˆ¶ç›¸å…³å‡½æ•°
    function startCustomShapeDrawing() {
       resetCustomShapeDrawing();
       
       // æ¸…ç†ä¹‹å‰çš„æ‰€æœ‰å›¾å½¢çŠ¶æ€
       currentShape = null;
       window.clippedShapes = [];
       penStrokes = [];
       currentStroke = null;
       isPenDrawing = false;
       cutCount = 0;
       selectedShapeIndex = -1;
       isShapeSelected = false;
       selectedShape = null;
       
       // æ¸…ç©ºå†å²è®°å½•
       stateHistory = [];
       
       isDrawingCustomShape = true;
       
       // è®¾ç½®å·¥å…·çŠ¶æ€ä¸ºnoneï¼Œé¿å…ä¸å…¶ä»–å·¥å…·å†²çª
       setCurrentTool('none');
       
       // æ˜¾ç¤ºç»“æŸç»˜åˆ¶æŒ‰é’®
       finishDrawingBtn.style.display = 'inline-block';
       
       // æ›´æ–°æŒ‰é’®ç¦ç”¨çŠ¶æ€
       updateCustomDrawingButtonsState();
       
       // æ¸…ç©ºç”»å¸ƒå¹¶æ˜¾ç¤ºç½‘æ ¼
       ctx.clearRect(0, 0, canvas.width, canvas.height);
       if (showGrid) {
           drawGrid(getCurrentGridSize());
       }
       
       // æ›´æ–°æ’¤é”€æŒ‰é’®çŠ¶æ€
       updateUndoButton();
       
       // æ˜¾ç¤ºæç¤ºä¿¡æ¯
       messageEl.textContent = 'ç‚¹å‡»ç”»å¸ƒç»˜åˆ¶è‡ªå®šä¹‰å›¾å½¢ï¼Œç‚¹å‡»"ç»“æŸç»˜åˆ¶"æŒ‰é’®å®Œæˆ';
       
       debug('å¼€å§‹è‡ªå®šä¹‰å›¾å½¢ç»˜åˆ¶æ¨¡å¼');
   }
     
     function resetCustomShapeDrawing() {
        isDrawingCustomShape = false;
        customShapeVertices = [];
        tempCustomVertex = null;
        
        // éšè—ç»“æŸç»˜åˆ¶æŒ‰é’®
        finishDrawingBtn.style.display = 'none';
        
        // æ¢å¤æŒ‰é’®çŠ¶æ€
        updateCustomDrawingButtonsState();
        
        debug('é‡ç½®è‡ªå®šä¹‰å›¾å½¢ç»˜åˆ¶çŠ¶æ€');
    }
     
     function finishCustomShapeDrawing() {
           if (customShapeVertices.length >= 3) {
               // åˆ›å»ºè‡ªå®šä¹‰å›¾å½¢
               currentShape = {
                   vertices: [...customShapeVertices],
                   color: '#4c8dbd',
                   strokeColor: '#1e5b98',
                   lineWidth: 2,
                   edges: []
               };
               
               // åˆ›å»ºè¾¹åˆ—è¡¨
               for (let i = 0; i < customShapeVertices.length; i++) {
                   currentShape.edges.push({
                       start: i,
                       end: (i + 1) % customShapeVertices.length
                   });
               }
                
                // é‡ç½®ç»˜åˆ¶çŠ¶æ€
                resetCustomShapeDrawing();
                
                // æ¢å¤å·¥å…·çŠ¶æ€ï¼Œå…è®¸ç”¨æˆ·ä½¿ç”¨å‰ªåˆ€å’Œç”»ç¬”å·¥å…·
                setCurrentTool('none');
                
                // é‡æ–°ç»˜åˆ¶
                drawShape();
                
                messageEl.textContent = 'è‡ªå®šä¹‰å›¾å½¢åˆ›å»ºå®Œæˆï¼ç°åœ¨å¯ä»¥ä½¿ç”¨å‰ªåˆ€æˆ–ç”»ç¬”å·¥å…·ã€‚';
                setTimeout(() => {
                    if (messageEl.textContent === 'è‡ªå®šä¹‰å›¾å½¢åˆ›å»ºå®Œæˆï¼ç°åœ¨å¯ä»¥ä½¿ç”¨å‰ªåˆ€æˆ–ç”»ç¬”å·¥å…·ã€‚') {
                        messageEl.textContent = '';
                    }
                }, 3000);
                
                debug(`è‡ªå®šä¹‰å›¾å½¢åˆ›å»ºå®Œæˆï¼Œé¡¶ç‚¹æ•°: ${customShapeVertices.length}`);
         } else {
             messageEl.textContent = 'è‡³å°‘éœ€è¦3ä¸ªé¡¶ç‚¹æ‰èƒ½åˆ›å»ºå›¾å½¢';
             setTimeout(() => {
                 if (messageEl.textContent === 'è‡³å°‘éœ€è¦3ä¸ªé¡¶ç‚¹æ‰èƒ½åˆ›å»ºå›¾å½¢') {
                     messageEl.textContent = '';
                 }
             }, 2000);
         }
     }
      
     // å¤„ç†è‡ªå®šä¹‰å›¾å½¢ç‚¹å‡»äº‹ä»¶
     function handleCustomShapeClick(mouseX, mouseY) {
         // å¸é™„åˆ°ç½‘æ ¼
         const gridSize = getCurrentGridSize();
         const snappedX = Math.round(mouseX / gridSize) * gridSize;
         const snappedY = Math.round(mouseY / gridSize) * gridSize;
         
         // æ·»åŠ é¡¶ç‚¹
         customShapeVertices.push({ x: snappedX, y: snappedY });
         
         // é‡æ–°ç»˜åˆ¶
         drawCustomShapePreview();
         
         // æ›´æ–°æ’¤é”€æŒ‰é’®çŠ¶æ€
         updateUndoButton();
         
         debug(`æ·»åŠ è‡ªå®šä¹‰å›¾å½¢é¡¶ç‚¹: (${snappedX}, ${snappedY}), æ€»é¡¶ç‚¹æ•°: ${customShapeVertices.length}`);
     }
     
     // å¤„ç†ç»“æŸç»˜åˆ¶æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    function handleFinishDrawing() {
        if (isDrawingCustomShape) {
            finishCustomShapeDrawing();
        }
    }
     
     // ç»˜åˆ¶è‡ªå®šä¹‰å›¾å½¢é¢„è§ˆ
     function drawCustomShapePreview() {
         // æ¸…ç©ºç”»å¸ƒ
         ctx.clearRect(0, 0, canvas.width, canvas.height);
         
         // ç»˜åˆ¶ç½‘æ ¼
         if (showGrid) {
             drawGrid(getCurrentGridSize());
         }
         
         // ç»˜åˆ¶å·²æœ‰çš„é¡¶ç‚¹å’Œè¿çº¿
         if (customShapeVertices.length > 0) {
             ctx.strokeStyle = '#1e5b98';
             ctx.fillStyle = 'rgba(76, 141, 189, 0.3)';
             ctx.lineWidth = 2;
             
             ctx.beginPath();
             ctx.moveTo(customShapeVertices[0].x, customShapeVertices[0].y);
             
             for (let i = 1; i < customShapeVertices.length; i++) {
                 ctx.lineTo(customShapeVertices[i].x, customShapeVertices[i].y);
             }
             
             // å¦‚æœæœ‰3ä¸ªæˆ–æ›´å¤šé¡¶ç‚¹ï¼Œæ˜¾ç¤ºé—­åˆé¢„è§ˆ
             if (customShapeVertices.length >= 3) {
                 ctx.lineTo(customShapeVertices[0].x, customShapeVertices[0].y);
                 ctx.fill();
             }
             
             ctx.stroke();
             
             // ç»˜åˆ¶é¡¶ç‚¹
             ctx.fillStyle = '#4c8dbd';
             for (const vertex of customShapeVertices) {
                 ctx.beginPath();
                 ctx.arc(vertex.x, vertex.y, 5, 0, Math.PI * 2);
                 ctx.fill();
             }
         }
     }
     
     // æ›´æ–°æ’¤é”€æŒ‰é’®çŠ¶æ€
     function updateUndoButton() {
         if (undoBtn) {
             let canUndo = false;
             
             // æ£€æŸ¥ä¸åŒçŠ¶æ€ä¸‹æ˜¯å¦å¯ä»¥æ’¤é”€
             if (isDrawingCustomShape && customShapeVertices.length > 0) {
                 // è‡ªå®šä¹‰ç»˜å›¾çŠ¶æ€ï¼šæœ‰é¡¶ç‚¹å¯ä»¥æ’¤é”€
                 canUndo = true;
             } else if (currentTool === 'pen' && penStrokes.length > 0) {
                 // ç”»ç¬”çŠ¶æ€ï¼šæœ‰ç¬”ç”»å¯ä»¥æ’¤é”€
                 canUndo = true;
             } else if (stateHistory.length > 0) {
                 // é»˜è®¤çŠ¶æ€ï¼šæœ‰å†å²è®°å½•å¯ä»¥æ’¤é”€
                 canUndo = true;
             }
             
             undoBtn.disabled = !canUndo;
             undoBtn.style.opacity = canUndo ? '1' : '0.5';
         }
     }
     
     // æ›´æ–°è‡ªå®šä¹‰ç»˜å›¾çŠ¶æ€ä¸‹çš„æŒ‰é’®ç¦ç”¨çŠ¶æ€
     function updateCustomDrawingButtonsState() {
         const isCustomDrawing = isDrawingCustomShape;
         
         // ç¦ç”¨å‰ªåˆ€å·¥å…·
         if (scissorsBtn) {
             scissorsBtn.disabled = isCustomDrawing;
             scissorsBtn.style.opacity = isCustomDrawing ? '0.5' : '1';
             if (isCustomDrawing) {
                 scissorsBtn.title = 'è‡ªå®šä¹‰ç»˜å›¾æ¨¡å¼ä¸‹ä¸å¯ä½¿ç”¨å‰ªåˆ€å·¥å…·';
             } else {
                 scissorsBtn.title = '';
             }
         }
         
         // ç¦ç”¨ç”»ç¬”å·¥å…·
         if (penBtn) {
             penBtn.disabled = isCustomDrawing;
             penBtn.style.opacity = isCustomDrawing ? '0.5' : '1';
             if (isCustomDrawing) {
                 penBtn.title = 'è‡ªå®šä¹‰ç»˜å›¾æ¨¡å¼ä¸‹ä¸å¯ä½¿ç”¨ç”»ç¬”å·¥å…·';
             } else {
                 penBtn.title = '';
             }
         }
         
         // ç¦ç”¨æ—‹è½¬45Â°æŒ‰é’®
         if (rotateBtn) {
             rotateBtn.disabled = isCustomDrawing;
             rotateBtn.style.opacity = isCustomDrawing ? '0.5' : '1';
             if (isCustomDrawing) {
                 rotateBtn.title = 'è‡ªå®šä¹‰ç»˜å›¾æ¨¡å¼ä¸‹ä¸å¯ä½¿ç”¨æ—‹è½¬åŠŸèƒ½';
             } else {
                 rotateBtn.title = '';
             }
         }
         
         // ç¦ç”¨æ°´å¹³ç¿»è½¬æŒ‰é’®
         if (flipHorizontalBtn) {
             flipHorizontalBtn.disabled = isCustomDrawing;
             flipHorizontalBtn.style.opacity = isCustomDrawing ? '0.5' : '1';
             if (isCustomDrawing) {
                 flipHorizontalBtn.title = 'è‡ªå®šä¹‰ç»˜å›¾æ¨¡å¼ä¸‹ä¸å¯ä½¿ç”¨ç¿»è½¬åŠŸèƒ½';
             } else {
                 flipHorizontalBtn.title = '';
             }
         }
         
         // ç¦ç”¨è®¾ç½®ä¸»ä½“æŒ‰é’®
         if (setMainShapeBtn) {
             setMainShapeBtn.disabled = isCustomDrawing;
             setMainShapeBtn.style.opacity = isCustomDrawing ? '0.5' : '1';
             if (isCustomDrawing) {
                 setMainShapeBtn.title = 'è‡ªå®šä¹‰ç»˜å›¾æ¨¡å¼ä¸‹ä¸å¯ä½¿ç”¨è®¾ç½®ä¸»ä½“åŠŸèƒ½';
             } else {
                 setMainShapeBtn.title = '';
             }
         }
         
         // ç¦ç”¨å¤åˆ¶æŒ‰é’®
         if (copyBtn) {
             copyBtn.disabled = isCustomDrawing;
             copyBtn.style.opacity = isCustomDrawing ? '0.5' : '1';
             if (isCustomDrawing) {
                 copyBtn.title = 'è‡ªå®šä¹‰ç»˜å›¾æ¨¡å¼ä¸‹ä¸å¯ä½¿ç”¨å¤åˆ¶åŠŸèƒ½';
             } else {
                 copyBtn.title = '';
             }
         }
         
         // ç¦ç”¨ç½‘æ ¼æŒ‰é’®
         if (gridBtn) {
             gridBtn.disabled = isCustomDrawing;
             gridBtn.style.opacity = isCustomDrawing ? '0.5' : '1';
             if (isCustomDrawing) {
                 gridBtn.title = 'è‡ªå®šä¹‰ç»˜å›¾æ¨¡å¼ä¸‹ä¸å¯åˆ‡æ¢ç½‘æ ¼';
             } else {
                 gridBtn.title = '';
             }
         }
     }

     // å¤åˆ¶é€‰ä¸­å›¾å½¢çš„å‡½æ•°
     function copySelectedShape() {
         debug('å¼€å§‹å¤åˆ¶é€‰ä¸­å›¾å½¢');
         
         // æ£€æŸ¥æ˜¯å¦æœ‰é€‰ä¸­çš„å›¾å½¢
         if (!isShapeSelected) {
             messageEl.textContent = 'è¯·å…ˆé€‰ä¸­ä¸€ä¸ªå›¾å½¢è¿›è¡Œå¤åˆ¶ï¼';
             setTimeout(() => {
                 if (messageEl.textContent === 'è¯·å…ˆé€‰ä¸­ä¸€ä¸ªå›¾å½¢è¿›è¡Œå¤åˆ¶ï¼') {
                     messageEl.textContent = '';
                 }
             }, 2000);
             return;
         }
         
         // ä¿å­˜å½“å‰çŠ¶æ€ç”¨äºæ’¤é”€
         saveCurrentState();
         
         let shapeToCopy = null;
         
         // å¦‚æœé€‰ä¸­çš„æ˜¯ä¸»ä½“å›¾å½¢
         if (selectedShape === 'main' && currentShape) {
             shapeToCopy = {
                 vertices: [...currentShape.vertices],
                 color: currentShape.color,
                 strokeColor: currentShape.strokeColor,
                 lineWidth: currentShape.lineWidth
             };
         }
         // å¦‚æœé€‰ä¸­çš„æ˜¯è£åˆ‡å›¾å½¢
         else if (selectedShapeIndex >= 0 && selectedShapeIndex < window.clippedShapes.length) {
             const selectedClippedShape = window.clippedShapes[selectedShapeIndex];
             shapeToCopy = {
                 vertices: [...selectedClippedShape.vertices],
                 color: selectedClippedShape.color,
                 strokeColor: selectedClippedShape.strokeColor,
                 lineWidth: selectedClippedShape.lineWidth
             };
         }
         
         if (shapeToCopy) {
             // è®¡ç®—åç§»é‡ï¼Œè®©å¤åˆ¶çš„å›¾å½¢ç¨å¾®åç§»ä¸€ç‚¹ä½ç½®
             const offset = 30;
             const copiedVertices = shapeToCopy.vertices.map(vertex => ({
                 x: vertex.x + offset,
                 y: vertex.y + offset
             }));
             
             // åˆ›å»ºå¤åˆ¶çš„å›¾å½¢
             const copiedShape = {
                 vertices: copiedVertices,
                 color: shapeToCopy.color,
                 strokeColor: shapeToCopy.strokeColor,
                 lineWidth: shapeToCopy.lineWidth
             };
             
             // å°†å¤åˆ¶çš„å›¾å½¢æ·»åŠ åˆ°è£åˆ‡å›¾å½¢æ•°ç»„ä¸­
             if (!window.clippedShapes) {
                 window.clippedShapes = [];
             }
             window.clippedShapes.push(copiedShape);
             
             // é€‰ä¸­æ–°å¤åˆ¶çš„å›¾å½¢
             selectedShapeIndex = window.clippedShapes.length - 1;
             selectedShape = null;
             isShapeSelected = true;
             
             // é‡æ–°ç»˜åˆ¶
             drawShape();
             
             // æ˜¾ç¤ºæˆåŠŸæç¤º
             messageEl.textContent = 'å›¾å½¢å¤åˆ¶æˆåŠŸï¼';
             setTimeout(() => {
                 if (messageEl.textContent === 'å›¾å½¢å¤åˆ¶æˆåŠŸï¼') {
                     messageEl.textContent = '';
                 }
             }, 2000);
             
             // æ›´æ–°æ’¤é”€æŒ‰é’®çŠ¶æ€
             updateUndoButton();
             
             debug('å›¾å½¢å¤åˆ¶å®Œæˆ');
         } else {
             messageEl.textContent = 'å¤åˆ¶å¤±è´¥ï¼Œæœªæ‰¾åˆ°æœ‰æ•ˆçš„å›¾å½¢ï¼';
             setTimeout(() => {
                 if (messageEl.textContent === 'å¤åˆ¶å¤±è´¥ï¼Œæœªæ‰¾åˆ°æœ‰æ•ˆçš„å›¾å½¢ï¼') {
                     messageEl.textContent = '';
                 }
             }, 2000);
         }
     }
     
     // åˆ é™¤é€‰ä¸­çš„å›¾å½¢
     function deleteSelectedShape() {
         debug('å¼€å§‹åˆ é™¤é€‰ä¸­çš„å›¾å½¢');
         
         // æ£€æŸ¥æ˜¯å¦æœ‰å›¾å½¢é€‰ä¸­
         if (selectedShapeIndex === -1 && (!isShapeSelected || selectedShape !== 'main')) {
             messageEl.textContent = 'è¯·å…ˆé€‰ä¸­è¦åˆ é™¤çš„å›¾å½¢ï¼';
             setTimeout(() => {
                 if (messageEl.textContent === 'è¯·å…ˆé€‰ä¸­è¦åˆ é™¤çš„å›¾å½¢ï¼') {
                     messageEl.textContent = '';
                 }
             }, 2000);
             return;
         }
         
         // æ£€æŸ¥ä¿æŠ¤æœºåˆ¶ï¼šç¡®ä¿è‡³å°‘ä¿ç•™ä¸€ä¸ªå›¾å½¢
         const totalShapes = (window.clippedShapes ? window.clippedShapes.length : 0) + (currentShape && currentShape.vertices && currentShape.vertices.length > 0 ? 1 : 0);
         
         if (totalShapes <= 1) {
             messageEl.textContent = 'æ— æ³•åˆ é™¤ï¼Œç”»å¸ƒä¸­è‡³å°‘éœ€è¦ä¿ç•™ä¸€ä¸ªå›¾å½¢ï¼';
             setTimeout(() => {
                 if (messageEl.textContent === 'æ— æ³•åˆ é™¤ï¼Œç”»å¸ƒä¸­è‡³å°‘éœ€è¦ä¿ç•™ä¸€ä¸ªå›¾å½¢ï¼') {
                     messageEl.textContent = '';
                 }
             }, 3000);
             return;
         }
         
         // ä¿å­˜å½“å‰çŠ¶æ€ä»¥æ”¯æŒæ’¤é”€
         saveCurrentState();
         
         if (selectedShapeIndex !== -1) {
             // åˆ é™¤é€‰ä¸­çš„è£åˆ‡å›¾å½¢
             debug(`åˆ é™¤è£åˆ‡å›¾å½¢ï¼Œç´¢å¼•: ${selectedShapeIndex}`);
             
             if (window.clippedShapes && selectedShapeIndex < window.clippedShapes.length) {
                 window.clippedShapes.splice(selectedShapeIndex, 1);
                 
                 // é‡ç½®é€‰ä¸­çŠ¶æ€
                 selectedShapeIndex = -1;
                 isShapeSelected = false;
                 selectedShape = null;
                 
                 // é‡æ–°ç»˜åˆ¶ç”»å¸ƒ
                 drawShape();
                 
                 // æ›´æ–°æ’¤é”€æŒ‰é’®çŠ¶æ€
                 updateUndoButton();
                 
                 messageEl.textContent = 'å›¾å½¢åˆ é™¤æˆåŠŸï¼';
                 setTimeout(() => {
                     if (messageEl.textContent === 'å›¾å½¢åˆ é™¤æˆåŠŸï¼') {
                         messageEl.textContent = '';
                     }
                 }, 2000);
                 
                 debug('è£åˆ‡å›¾å½¢åˆ é™¤å®Œæˆ');
             }
         } else if (isShapeSelected && selectedShape === 'main') {
             // åˆ é™¤ä¸»ä½“å›¾å½¢
             debug('åˆ é™¤ä¸»ä½“å›¾å½¢');
             
             if (currentShape && currentShape.vertices && currentShape.vertices.length > 0) {
                 // æ¸…ç©ºä¸»ä½“å›¾å½¢
                 currentShape = null;
                 
                 // é‡ç½®é€‰ä¸­çŠ¶æ€
                 isShapeSelected = false;
                 selectedShape = null;
                 selectedShapeIndex = -1;
                 
                 // é‡æ–°ç»˜åˆ¶ç”»å¸ƒ
                 drawShape();
                 
                 // æ›´æ–°æ’¤é”€æŒ‰é’®çŠ¶æ€
                 updateUndoButton();
                 
                 messageEl.textContent = 'ä¸»ä½“å›¾å½¢åˆ é™¤æˆåŠŸï¼';
                 setTimeout(() => {
                     if (messageEl.textContent === 'ä¸»ä½“å›¾å½¢åˆ é™¤æˆåŠŸï¼') {
                         messageEl.textContent = '';
                     }
                 }, 2000);
                 
                 debug('ä¸»ä½“å›¾å½¢åˆ é™¤å®Œæˆ');
             }
         }
     }
});

    </script>
</body>
</html>